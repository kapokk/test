# 操作系统

管程 每次只允许一个进程在内操作
管程包括多个方法 和 共享变量 每次只能一个进程调用一个方法 
管程可以wait 变量以实现同步 wait时调用者会撤出管程，让出使用权

死锁
注意请求信号量一定要比请求互斥量先执行，释放信号量一定要在释放互斥量后执行，互斥量执行在最里层，否则会死锁
至少两个进程出现互相等待对方资源的情况
死锁产生的必要条件：1.资源互斥 2.请求新资源却不释放资源 3.几个用户同时等待同种资源 4.没有外界干预他们的等待（不剥夺）
其中一个不成立，就不会有死锁
解决死锁的思路有三种 消除死锁产生的条件；；；避免死锁；；；检测死锁

避免死锁算法：银行家算法
在每次分配资源前检查此分配是否会导致系统不安全
有m个进程，n个资源，1.维护一个m行3列的表，第一列是进程最大资源需求 第二列是已分配资源向量 第三列是进程最多还需要资源（最大量-已分配）；；；2.维护一个剩余资源向量；；；3.维护一个进程请求向量
然后进程请求资源时执行以下操作
1.检查如果分配了资源请求是否到达进程最大需求，是则跳出
2.需求资源是否小于资源存量，否则退出
3.更新已分配资源（加上请求资源）和资源存量（减去请求资源）和进程还需要多少资源（减去请求资源）
然后对于所有剩下的资源，寻找需求量少于存量的进行满足，就是修改剩余资源为当前剩余资源+已分配资源，并把当前进程加入安全序列，后续扫描屏蔽这个进程表量
重复上述直到不满足或者全满足后 判断安全序列是否为所有进程，如果是 则分配可以进行，安全，否则不安全

解除死锁算法
系统维护一个图，记录进程和资源分配情况；；有两种节点 两种边 资源节点和进程节点 ；；；请求资源边和分配资源边
检测死锁有没有发生：
1.找进程节点，找进程节点请求边对应的（除去分配边和请求边后资源仍有剩余的）资源节点，此时删除进程节点的所有进边和出边
2.循环这个过程，直到找不到符合条件的节点
此时 如果图完全没有了边 说明没有死锁 否则 有边的节点就有死锁

死锁处理策略
1.挂起死锁进程
2.关闭死锁进程
3.死锁进程回退到没死锁的状态
处理优先级：
进程优先级，已运行时间，还要多久能完成，已使用资源，交互式进程还是非交互

-----
内存与进程运行
程序封装成可执行文件装入内存运行，可执行文件包括程序段和数据段
可执行文件可以是单程序 ， 程序+静态链接库 ， 程序+动态链接库
单程序，编译链接阶段就写死了程序段和数据段，直接装入内存运行
程序+静态链接库，装到内存前先链接在一起再装入内存
程序+动态链接库，程序先装入内存，在需要动态链接库时再装入到内存，同时操作程序中的相关操作地址，地址可不连续

进程装入内存也有三种方式
静态装入，指定死装到内存的哪里
运行前链接然后装入，程序里存在的是对数据逻辑地址的操作，装入时指定数据段起始地址从而进行地址重定位
运行后链接然后装入，运行时装入数据后把数据地址保存到重定位寄存器，然后重定位逻辑地址为物理地址

运行后装入需要对程序进行地址重定位，把逻辑地址转换为物理地址运行

内存保护（防止进程越界访问内存）
1.设置进程内存上下限
2.设置重定位寄存器 和 界寄存器（存储最大逻辑地址）
注意逻辑地址是从程序指令段起始开始而不是数据段起始开始。

进程是内存分配管理的最小单位 不能把进程（程序）内的数据段拆分，碎片化
进程在内存内的映射 程序段， 只读数据， （静态变量，全局变量），堆（malloc），共享库函数，栈（记录当前运行步骤信息和局部变量）

内存分配，内存分区分配
内存分配分为连续内存区域分配和不连续分配
连续分配：：
         （维护一个分区表，包括分区号，大小，起始地址，状态）分区表只能看出空闲内存信息，已分配的进程是不包括在分区表中的？，进程分配后，重新计算该分区的起始位置和大小，更新
         1.单一分配 2.固定分区，分区大小固定或不固定  3.动态分区
         固定分区和单一分配有内部碎片
         动态分配有外部碎片
         动态分配内存可合并，相邻内存段合并成一段，
         动态分配的四种方法
         1.最近分配 2.最小大小分配 3.最大大小分配 4.就近分配
         最近分配查询开销小
         最小大小分配会导致很多细小碎片
         最大大小分配会使大内存被很快用完
         就近分配也会导致大内存快被用完，但是他的查询开销小
不连续分配
         分页分配
                  相关概念：分页 页大小 逻辑地址 物理地址 页号 页内偏移
                  把内存分为固定大小的页，然后进程的可执行文件同样按照固定大小分页，程序分页后乱序装入内存中，同时维护一个进程页表（在PCB中存页表存的地址和页表长度）
                  ，存储逻辑页号和物理页号的一一对应关系 ；；；因为页表逻辑序号是顺序的，直接用数组下标表示逻辑页号，用元素值表示物理页号
                  此时就要把逻辑地址转成物理地址，当程序访问某块地址时，求逻辑地址对应的物理地址再访问
                  求法：物理地址 = 页初始地址+页内偏移
                                 = 逻辑页号对应物理页号 * 页大小 + 页内偏移
                                 = 逻辑地址整除页大小向下取整（得到逻辑页号）-》对应物理页号 + 逻辑地址%页大小（页内偏移）
                                    实际计算机算页起始地址和业内偏移是直接二进制掩码来取的，页大小占几字节，剩下的位数就表示片号
                  相关计算：一个页面大小为4KB，有2^12次方B，至少需要12b来表示（不过系统一般分配B的整数位来存页内偏移），假设系统字长32位，剩余20位可以用来表示页号，可表示2^20次方个页号
                  地址重定向：
                           程序运行前，从进程PCB里读取页表物理起始地址和页表长度到寄存器，然后当进程意图读取内存时，将逻辑地址转换为逻辑页号和页内偏移，首先检查逻辑页号是否大于页表长度，然后继续（页号+页表初始地址）得到逻辑页号所对应的物理页号，然后*页长得到物理页地址，然后+业内偏移读取到最后内存
                  --------
                  二级分页
                  给分页再分区间（目录），这样分页表的部分数据就就可以不用常驻内存
                  多级分页中各级目录表示位数不得大于页大小，因为大于页大小，表示的分页就超出了实际最大分页数
                  易错点：页号从0开始，如果页表长度位8，则可表示0-7，而不是0-8；；可表示数=右下标-左下标+1 = 长度+1
                           页大小为1K 那么物理页1的初始地址 = 1*1K 不是一千！！而是1024 ，业内偏移=逻辑地址%页大小 通常逻辑地址单位是B ，页大小要转为B 比如1K转1024B 不是1000B
                           页表内的块号大小取决于内存大小和页大小，需要表示这么多页，而块大小就是页面大小
                           名词区分：页面是一个分页，页框也是一个分页，页长度是分页长度，页表项长度是页表里的每一项的长度（需要符合能表示内存内所有页序号）
         快表
                  把分页表一部分克隆到TLB（一种缓存）中，进程访问内存时，优先查快表，拿到分页号和业内偏移之后，在快表找页号（快表的页号是有页号字段的），没命中把这个分页表段加入快表，然后查内存分页表，
                  局部性原理：程序的运行有空间局部性和时间局部性，程序的代码段可能在短时间内再次运行，访问过的内存可能再次访问，所以把他加进块表中
                  有的系统支持同时查快表和内存，此时如果快表没有命中 ，耗时是（查快表耗时+访问内存耗时）*命中率 + （两次访问内存耗时）*非命中率
         分段存储
                  分页是页大小均分，分段是段大小不均分，是根据逻辑分段的（比如函数作用域内分一段）
                  分段可以更好实现不同进程间 不同子函数间的信息共享 比如两进程调用同一方法，只需要指针指向共享方法的地址即可，如果用分页，额不知道为啥不行
                  分段对用户可见（汇编层？）
                  -----
                  具体实现
                  维护一个分段表，索引表示分段号，有两各元素，段起始位置和段长，PCB中存储分段表起始地址和分段表长
                  进程的地址存储方法有所改变，是逻辑分段号+段内偏移
                  进程读取内存时，提取内存的逻辑段号和偏移，判断逻辑段号是否大于段表长，然后段表起始地址+逻辑段号，得到逻辑段号对应的表项，判断偏移是否大于段长，否则段起始地址+偏移取得内存
         ----
         段页式存储
                  分段后每个段内再分页
                  此时段表存储段号（索引），页号，页长度，，，页存储页号（索引），内存块号
                  实现了段内资源无碎片

虚拟内存：
         包括页面请求算法和页面置换算法
         首先要修改页表结构，包括页号，内存地址，外存地址，是否在内存中，访问字段，修改字段
         页面请求，扫描页表，判断是否在内存中，不在则触发缺页中断（cpu fault中断），如果内存没满等待io复制号内存后唤醒，
         如果内存满了，页面置换，置换一个现有内存页（如果修改位没变不用换），调用设备io
         注意页面请求和页面置换时分别要页表段加入和删出快表
         ---
         内存置换方法
                  1.FIFO 先进先出 不好用
                  2.最近时间没用的先出
                           页表访问字段放最近调用时间
                  3.时钟置换算法
                           把该进程的页表段连成循环链表（就像时钟），然后每一轮扫描360度，扫描多轮来置换
                           原则是选择最近没用到的页面进行置换，访问字段位0没用，1用了，每轮扫描扫描到的访问字段归0
                           选择0的出
                  4.改善时钟置换算法（加了修改位的判断）
                           扫描有变化
                           第一轮扫描访问0，修改1的出去，没有进行第二轮
                           第二轮扫描访问0，修改0的出去
                           第三轮0，1
                           第四轮，0，0
                           性质决定了最多扫描四轮
         内存文件映射：
                  文件放进虚拟内存里

文件存储（文件是操作系统重点）：
         文件逻辑上：分为无结构文件和有结构文件
                  有结构文件有三部分组成：顺序文件，索引文件，索引顺序文件
                           顺序文件分为定长记录文件和不定长记录文件，定长文件顺序存储可以随机访问，链式不行，不定长记录文件不能随机访问
                           索引文件就是指向逻辑文件块的表
                           索引顺序文件是索引文件的优化，索引与文件块之间不再一一对应，而是一个索引对应一组条件划分的文件块区的起始逻辑地址，使得索引空间缩小
         文件物理上：
                  三类：顺序结构，链式结构，索引结构；；；链式结构又分为显式链接和隐式链接
                  顺序结构即文件存储在磁盘块里面，不方便增删，但是方便顺序读写和随机存储，只需FCB给定起始物理块地址+长度即可遍历
                  链式结构：
                           隐式链接：链接存在块中，访问时链接下一跳，需要多次磁盘io，不方便
                           显式连接（全局索引）：整个磁盘维护一个文件链接表（FAT），索引表示物理块号，元素表示下一跳索引地址，这个表在内存中维持，就不用频繁io
                  索引结构（文件内索引）：
                           显式链接是全局索引，整个磁盘只维护一个索引表
                           这里的索引是指文件内索引，文件维护索引表（单，多个），此时FCB里存储存储的起始物理地址是索引表的起始物理地址
                           索引有链接索引，多级索引，混合索引，后两个，索引表的最大长度都不能超过一个磁盘块的长度（否则会越界）
                           索引的序号表示逻辑块号，内容表示物理块号
                           链接索引就是本来索引放在一个物理块上的，但是文件块数量（系统给出）大于索引能表示的长度，这时就留最后一点空间存放索引下一条；；；单块存储索引时，最大索引表长度 = 空间大小/块大小
                           多索引非最底层索引存储的是下一级索引表的地址，如果给定一个逻辑地址要查找，则逻辑号/i级索引表长度作为i级索引号前往下一跳，达到最底层索引时逻辑号%索引表长度得到最后索引跳向物理块号
                           混合索引：索引表前几个直接指向物理块，后几个一级索引，再后几个二级索引
                           -----
                           考点：
                                    1.根据索引结构计算最大存储长度
                                             如果是直接索引（链接索引），文件块数=索引表长度
                                             多级索引，文件块数=1级索引表长度*i级索引表长度...
                                             混合：两者混合
                                    2.磁盘io次数，链接索引要访问逻辑块号/索引表长度次；；；多级索引需要访问k级+1次io
         ------
         文件目录：
                  目录存储的是FCB（文件信息），FCB包括文件名，文件大小，权限，物理地址等信息
                  目录单级目录不支持同名，多级支持同名，有绝对路径，相对路径
                  还有无环图目录，类似linux的软连接吧，链接目标维持一个引用计数器，当所有引用都消失时，这个节点才会被删除
                  目录索引节点：不再存整个fcb太大了，把除了文件名的内容都放到一个索引节点指针上去
         -----
         磁盘被分成一个个文件卷，卷内有目录区和数据区
         -----
         文件存储管理：
                  分为分配和回收
                  空闲信息的记录方式
                           空闲表，存储空闲块号
                           空闲链表
                                    空闲块链，分配时从链头取，回收时从链尾取
                                    空闲区链，每个节点存储块号和区长，
                           位图法 二维数组表示空闲区块 行为字，列为字内偏移 i,j对应物理块号是i*字长+字内偏移；；；这里i是字数，从0开始，如果从1开始，表示字编号，要i-1 再 * 字长算偏移（0，1容易错）
                           成组链接法（适用于大型文件系统），维护超级表结构链（存在文件目录里），每个超级表是个数组，第一行存表长度，后面元素放空闲块，然后每个空闲块连接下一个超级表
                  文件的操作
                           系统会维护一个打开文件表，存储正在打开的文件，维护一个打开数，表示当前有多个进程打开，用户关一个，减1，为0则移出打开表
                  文件共享
                           硬链接：存储在目录索引表的索引节点中（索引表分为文件名，索引节点），索引节点维护一个链接数，多文件链接，如果链接源头被删除，不影响链接
                           软连接：目录索引表里的索引节点内放的是软连接文件的块号地址，磁盘io发现是软连接文件还得io一次，耗时长，源文件被删除，软连接还存在（硬链接源文件删除就不存在了？）
                  文件访问控制：
                           文件FCB里有个访问权限区
         虚拟文件系统：
                  不同的读取方式的文件系统的集成（UFS,FAT)，提供统一接口
         
# 计算机网络


犯错：：：
3bit能表示多少个数？ 2的三次方个 ；；但是最大表示值不是6 是2的三次方-1


浮点数存储
符号位 尾数 和阶数
尾数默认为1xxxxxx 所以第一个1省去 实际上只存储xxxxx，还原时记得加上，这里存储的是二进制真值

阶码用移码存储表示 阶码十转二 
十进制下表示二进制小数点移动的位数（移动到小数点前只有一个1）阶数 + (2^8) -1(阶数位【float为8】)，然后再转成二进制，所得的就是移码

移码2转10：
二进制按照十进制解读，然后减去2^n ) -1 得到的k就是2的k次方

尾数二转十
尾数最左端补1,然后小数点从最左端1后面移动阶数位（阶数是2的n次方的n转成移码，需要还原），然后再转10进制，小数点后二分之一四分之一六分之一....

十进制小数转二进制
乘基取整法 *2 取整 剩下的位继续*2 知道小数部分剩下0

补码转原码（负数）
除符号位取反 然后加1 （不是减1）
原码转补码 （负数）
除符号位取反 加1

浮点数的特殊值
阶数全0 尾数全0 是正负0
阶数全0 尾数不为0 非规格化数 转十进制 ： 尾数位最左边补0（0.xxx）然后算出十进制 再*2的-126次方
阶数全1 尾数全0 正负无限
阶数全1 尾数不为0 NaN
求表示范围时注意阶数位不能全0 全1

多路选择器的控制信号位数
选择k路 则需要log2 k 向上取整个信号

组成原理看到浮点数

数据结构：

二叉排序树没有值相同的节点
平衡二叉树的插入，删除，平衡
插入小于向左大于向右 插入到根节点
删除：1，待删除节点的直接前驱，直接后继，没有就直接删除 2，替换直接前驱后继和待删除节点的位置 3， 删除待删除节点（此时在叶子处） 4， 寻找最小不平衡二叉树，调整直到平衡
旋转：
前置知识：因为平衡因子为正负1时，树平衡，要不平衡至少为2，所以寻找最小不平衡二叉树，寻找平衡因子为2的最小子树
寻找最小不平衡子树，如果为往下看成因，看哪边高，往下找两层，看是LL,RR,LR,RL ,LL 的L节点往右旋，RR往左，LR先左再右，RL先右再左，然后递归网上查找不平衡 lss




计算机网络（经常需要B,b,之类的单位转换）
在计算机网络中M,G,T的值是10的369次方，和其他科不一样

Internet是互联网  inter是局域网 局域网不限协议 互联网是tcpip
通信方式：电路通信，报文通信，分组通信，电路通信直接但占据链路，报文通信没有差错纠正，

网络性能指标
带宽 信道最多每秒传输多少比特 b/s
时延带宽积 信道传输时间*带宽 表示最大信道容量
时延 对于单个比特或者报文通信模式 发送时延+传输时延；；；对于分组通信模式需要画时序图来求和，不是简单的累加，时序图每条线表示一个节点，然后在上面画平行四边形，画法：数据从最左边竖线出发，先确定竖边长度为分组数据量/发送速率，然后看下一跳线，向下走传输时延的长度，画发送时延长度的线，然后封闭两条线为平行四边形，这是一个分组，下一个分组紧随其后，用相同的做法画，最后计算整个竖线耗时，发现时延不是（发送时延+传输时延）* 分组量【因为中间传输时延不是累加关系】
RTT：从一个分组发送完成后开始，到接受完确认消息结束，中间的耗时是RTT
吞吐量：传输时间/总时间



信道性能指标：
带宽：波形频率，单位HZ
码元：1个周期的波可以表示多少种信号
码元比特转换：k进制码元 就是log_2^k个比特
波特率：码元/秒
比特率:  比特每秒  k进制码元每秒 = log_2^k比特每秒
信噪比/分贝信噪比 :信号功率/噪声功率,这是信噪比，没有单位，分贝信噪比：10log_10^(S/N) 这是分贝信噪比 数值表达范围更窄；；注意做题时分辨题目中的信噪比是有单位信噪比还是无单位，算法不一样，有单位还要转换为无单位才能算香农

理想最高波特率：2W,W是频率
噪声信道最高比特率 KW*log_2^(1+S/N)

注意理想信道公式算的是波特率，噪声信道最高比特率算的是比特率

网络分层模型
OSI模型 ， TCPIP模型，教材模型
教材模型：物理层，数据链路层，网络层，传输层，应用层
OSI：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层
TCPIP模型：网络接口层，网络层，传输层，应用层

OSI模型网络传输层和tcpip网络传输层的差别：
OSI模型网络传输层进行差错控制可靠传输流量控制 TCPIP的不进行差错控制可靠传输流量控制
UDP属于传输层的内容

循环冗余校验码的算法
基本元素：数据是待封装成循环冗余校验码的，通信双方商定一个生成多项式，循环冗余校验码分两部分1。数据部分 2.校验码
发送方校验码的计算
1.根据生成多项式P(X^n)构造除数，比如x^4 + 1对应的除数就是10001
2.数据扩容，在低位补0，补0的位数是除数的位数-1 ；；； 同时校验码的位数也是除数位数-1
3.进行一个特殊除法（异或除），其中得到的商不重要，不计算商，只关注余数
         除数右对齐，对齐到除数对应被除数首个不为0的元素
         进行异或运算，同0不同1
         得到的运算结果继续作为被除数进行异或除，如果被除数长度不够，就在根被除数上拉几位下来
         （终止条件是除法结果小于除数位数，并且根被除数没得借了）
         终止的除法结果就是校验位
4.把校验位加到数据低位，组成CRC校验码

接收方数据检错
用CRC码异或除约定生成多项式，直到终止时得最终商
商为0，正确，不为0，错误

可靠传输和流量控制 通过滑动窗口传输方法来实现，即重传ARQ协议
前置概念：丢序，数据帧，应答帧，超时重传，帧编号，滑动窗口n的长度 2^n>= 发送窗口+接收窗口
可靠传输和流量控制得实现要解决：数据帧丢失，应答帧丢失，数据帧出错，数据帧重复问题
停止等待协议（SW协议），发送方和接受方窗口大小为1，编号长度为1b（表示2个编号），发送方发送数据帧，接收方接收数据帧判断帧序号是否在滑动窗口内所需的阵序号内，校验是否通过，如果是则发送ACK，如果不是则不响应；；发送方超时没有收到应答帧重传

后退N帧数协议（GBN协议），发送窗口为N,接收窗口为1，发送方持续发送N帧数据，接收方接收数据返回ack，如果同时接收到N帧数据，则返回最后的有效数据的ACK，如果数据在接收者滑动窗口所需序列号之外或者校验未通过，则该数据无效，发送方如果第i帧超时没有收到ACK，则重新发送i和之后所有帧，如果接收到ACKi，说明i和之前的所有帧都传输完了；；；当数据帧丢失时，没有应答数据帧会超时，会发超时帧和之后的帧；；应答丢失也会重发；；；

选择重传协议（SR协议 select repeat）
发送窗口N,接收窗口m，m<n,发送窗口内每一帧，接收者每一帧ack，发送者每一帧超时没有收到ack重传，收到NAK否定帧重传，最左边帧确认后，发送窗口右移

可靠传输的信道利用率
发送窗口内所有数据时延/（发送到返回完第一个确认帧数的时延）
发送到返回完第一个确认帧数的时延 = data发送时延+数据传输时延*2 + ACK发送时延    ‘；；；； 对于重传和N帧数后退，信道利用率=NTD / (TD + RTT +TA)
信道利用率可以算最大通讯速率

码分复用和正交


可靠传输+冲突解决
aloha 立刻发送 随机重发
坚持监听csma 非坚持csma p坚持csma  及其优缺点
监听csma 监听为空，立即发送，发送失败随机重传
非坚持，监听为忙，随机时间后监听
p坚持csma，监听为空，p概率立即发送，1-p概率等待一段时间后继续监听

CSMA/CD协议
这个协议无冲突认为成功，不ACK
口诀 先听后发，边听边发，冲突停发，随机重发
概念：争用期，二进制指数退避算法，最大最小帧长，冲突检测分辨率
争用期：两倍最远单向传输时延
随即重发 等待时间为 r* 争用期 r的取值范围 取决于冲突次数，冲突小于10次 ，r属于(0,2^k -1) ,大于10次(2的10次方-1)
10，16
接收方处理
最短帧长 2*传播时延*带宽，小于这个视为无效帧
以太网最短最长帧长 ，64B,1518B
接收方帧处理 判断帧长丢弃，


CSMA/CA
口诀：发前监听，空闲间隔一段时间发，不空闲随机退避，退避使用随即退避，注意退避时会持续监听信道，只有信道不空闲时才继续倒计时
RTS CTS  请求帧，同意发送帧
DIFS 发送前等待时延
SIFS 接收方处理时延
DIFS > SIFS + 信道传播时延

令牌协议
令牌表示空闲，
令牌帧 数据帧 帧内容 令牌帧使用头尾和令牌号， 数据帧头尾+令牌好+数据+被使用号
令牌环网，小环组成大环

802.3 802.11局域网 以太局域网
8023是有线局域网 11是无线 以太局域网 MAC帧常规采用以太网的帧

双工通信不需要处理冲突 
无线局域网是星形拓扑结构
有线是总线型
光纤是点对点
MAC在数据链路层

同轴电缆只支持半双工
双绞线支持全双工或者半双工，在设备链接时决定
光纤只能全双工
集线器只支持半双工 交换机支持全双工

MAC地址位数？6B 
MAC帧的结构 662N4(B单位) 注意是先destination再source 然后是协议类型 数据 CRC
MAC发送帧前会发送同步8B的同步信号 是1010101最后是11 11说明开始发MAC 末尾的界定用违规曼彻斯特编码实现 编码使用曼彻斯特编码 （上0下1）
最短最长帧长 64到1500
交换机路由器有MAC地址 集线器没有
广播帧在同一个局域网内才能广播 路由器不转发广播帧
广播的实现 MAC地址全1就是广播
交换机隔离冲突域 路由器隔离广播域

局域网内广播：1 容易广播风暴 2.隐私性不好
引入虚拟局域网vlan
vlan 结构 划分方式 vid
vlan基于交换机实现 同时有基于接口的实现 基于MAC的实现 基于IP的实现
跨交换机通信使用802.1Q帧 6642N4 类似662N4 但是42部分是固定vlan识别号+随机+vid
同一个虚拟网共享一个vid

802.11协议
概念:BSS ESS SSID Portal 漫游 AP 帧分类 帧格式
AP wifi接入点
BSS 一个AP+多台主机
ESS 多个路由器和主机
SSID 服务集的id SS_id
漫游 主机从一个AP到另一个ap
采用802.11帧 有数据帧 控制帧(RTS,CTS,ACK) 管理帧（探测）
帧结构 控制，持续时间，AP MAC，source mac ， des mac 。。。后面省略


交换机原理
维护MAC路由表 设定超时丢弃 自动记录MAC对应端口号
转发方式 直接转发 处理MAC帧 662N4里的第一个6 也就是destination
存储转发 存储 差错校验 然后转发

网络层
ip数据报结构
首部+数据
首部：版本，首部长度单位4B,服务，数据报长度（以1B为单位），分片标识，标志位（后续是否还有分片，是否允许拆分），片偏移单位8B，源，目标，可选
注意 除了最后一部分，每一部分数据长度都要是8B的整数倍，最后一部分可以不是8B的整数倍  因为片偏移是8B

ip初版
主机号全0，主机号全1，网络号不为0，分别是表示本网络和网络内广播
n比特主机号能表示2^n - 2 个设备 有两个全零全1不行

子网掩码转发规则
目标ip & 子网掩码后和路由表的网络号对的上，就发

路由器的接的不同子网都要分配一个子网号

注意题型 可分配子网Ip号要减去2，因为全0 全1 不能分配给设备

CIDR划分 ， 变长子网划分
分配方式 从原子网号开始，每次加一位，左0右1，分配子网，剩下的位数-2 就是设备数

0.0.0.0是网络入口IP地址，目标是入口所在端口不转发（没有ip匹配不转发）

CIDR路由聚合 当路由表端口相同且子网号相同则合并 
CIDR最长前缀匹配原则 对于两个相同的ip ， 端口不同，优先选子网号更长的一个

NAT协议 内外网协议 维护一个内网+端口对应外网+端口表 每次穿越内外网边界时修改帧的ip 端口号 是传输层的协议

ARP MAC对应IP 协议有请求帧和响应帧 请求mac全1广播 因为是MAC帧 要符合最短长度 要填充

DHCP协议 是应用层协议 是UDp的应用 基于广播通信
四种帧 发现帧 主动上报mac  提供帧 提供ip地址 请求帧 客户向服务器请求 确认帧 服务器确认ip
四种都是广播 因为DHCp服务器同网络有多个 每个都需要知道i

ICMP协议 属于IP的子协议 封装在IP数据报内 负责报告网络间的一些一场消息
包括终点不可达 超时 参数错误 改变路由 ；；； 还有发请求和发回应（ping） 还有时间戳请求 和应答
对于一些特殊情况icmp不处理 比如来自0.0.0.0,127.0.0.1


IPV6 一百二十八位 用十六进制冒号分法表示 压缩表示：每个段之间前q个0可以省略，再压缩  连续出现的0用：：双冒号省略，但是双冒号只能有一个 ，多个不知道终结缺几个0
有单播多播本地播任一播等 支持新设备直接接入不需要DHCP 直接mac地址


IP路由协议
静态路由
动态路由 RIP OSPF
自治系统 bgp as号 内部网关协议 外部网关协议 自治区平级不包含

RIp
应用层协议 udp传输
有请求帧和应答帧
传输路由表 每个帧最多25个表 要拆分传
路由表格式 目标地址 跳数 下一跳路由器
固定时间交换 触发更新
RIP 十六跳 不可达

RIP的路由表更新
起始 只知道相邻网络的id
然后接收到rip报，进行修改，目标地址不变，跳数+1，下一跳地址改成数据来源
然后和本机路由表比较 如果目标网络是新的 加入 如果目标网络已存在，且下一跳一样 比较跳数 跳数小 更新 ；；下一跳不一样 目标地址一样 更新，以最新的为准

此外 RIP检查下一跳（邻居）150秒内不活着就不可达

RIP的特性
更短路由传得快 路由故障传得慢
RIp还会产生回环 所以用最远跳16来防止回环无线传播

OSPF路由协议
与RIP是应用层的协议不同 这是网络层的协议
包含5种类型数据
问候帧
数据库描述帧
链路状态请求帧
链路状态更新帧
链路确认帧
根据图数据库用djistra算法求到每个节点的最短路径

流程：
开机先检测直连网络
然后泛洪法（不能回流）广播自己的链路数据库
如果链路有变化 立即广播数据表最新
数据帧存储一个序号说明最新消息
支持真假信息鉴别

维护的路由表格式
目标 下一跳 代价 

作为内部路由协议 运行在自治区内 自治区里节点太多 ospf数据库负载大 又继续分区 分为主干区和非主干区 主干区至少有一个自治区边界路由器
分区内有区域内路由 和 区域边界路由

LSDB 链路状态数据库 LSA 链路通告 LSI链路描述信息


UDP协议
结构：源端口号，目标端口号，数据报长度（1B为单位），校验和；；；数据块 数据块受限于ip报数据块大小 65515B（65535-20)
不支持拆分 拥塞控制
校验和的计算：
对首部+数据进行校验和 校验和方法为整个数据报的每16位累加 累加完后取反 得到校验和
接收方拿到数据报后 整个数据报每16位相加 得到结果如果为全1 则正确 非全1 则错误
注意udp校验和计算前要加伪首部（源ip 目标ip 固定模板 udp数据报长度） 然后再校验和计算 发送方接收方都需要先加伪首部
校验和累加过程中最高位产生进位要加回最低位

于ip数据包不同 ip数据包校验和不要伪首部，而且只计算首部校验和 而udp是全数据


TCP协议
四个考点 连接管理 可靠传输 流量控制 拥塞控制
三次交替握手 四次交替挥手
可拆分
TCP数据包头部结构：源端口，目的端口，数据序号（当前报文数据相当于所有数据的第几个字节）seq，确认序号（确认第几个字节前都收到了）ack_seq[ack]，数据偏移（TCP帧中数据在多少个字节后（单位4B），保留，URG（紧急信息，另外编号，编号存在紧急指针），ACK（表示是应答帧），PSH（需要尽快回答），RST（终止连接），SYN（同步中，前两次握手报为1，其他时候0），FIN（1，3次挥手为1，其他为0），窗口大小(rwnd receive window)（确认号算起，接收方还有多大缓冲区,单位KB），，校验和（也要加伪首部），紧急指针（存放紧急数据序号），可变区间（存放单报文最大传输数据量)英文MSS max segment size

注意seq含义是第一个字节是序号几 而ack含义是序号几前已经接收完 也就是ack-1才是接收到的数据最后一个序号


三次握手过程和进程状态转换
1.客户端发送同步请求 syn=1,ACK=0,seq随机一个,ack_seq随便;;；；；进程状态转为同步已发送
2.服务器接收到同步请求 发送同步请求 syn=1,ack=1,seq随机，ack_seq固定是客户端的seq+1,；；；；；进程状态转为信号已收到
3.客户端收到同步请求，准备发送数据了，发送syn=0,ACK=1,seq=服务器同步帧的ack序号，ack是服务端请求帧的seq+1 ;;;第三次握手可以携带数据，如果携带数据，服务器接收到后下一次ack就收成功就要加数据大小（字节）；；；双方进程状态转为已建立连接
建立连接耗时1.5RTT 从开始建立到可以发送数据耗时1RTT

特性：TCP除了握手第一帧ACK为0 知道结束完ACK都为1  
握手建立的23次握手ack都要+1，都消耗数据序号 
挥手13次ack都要+1

四次挥手
FIN交替分别为1,0,1,0 ,收信息者每次都要ack=发送者 seq+1
挥手提出者刚提出还能发一次数据 后面不能发了，如果提出者没有在挥手时发送数据，被动者无需关闭等待直接发挥手3，然后主动者直接发挥手4，注意有个坑，这样的话被动者释放时间就是1.5RTT，主动者释放时间就是1RTT+2MSL 
MSL 是最长报文段时间 系统给定 
挥手过程 A说88，b说收到88了，B说88，A收到88 ，然后A看着B走远，双方收到 关闭
状态发送者先进入FIN_wait1 再进入fin_wait2 再进入time_wait （2MSL）再结束，，接收者先close wait ，lastack，然后close
注意挥手发送者要再见后主动等待2MSL

可靠传输
可靠传输分为确认机制和重传机制
确认机制特性
    延迟确认，确认时寻找最高seq顺序连续的数据的最后以字节的索引设为ack_seq 说明ack_seq前面的所有字节已收到
        如果接收方有数据发送，可以捎带在ACK确认帧中
        如果连续收到两个最大传输长度MSS的报文，立即ACK
        接收完数据之后，ACK时调整接收窗口剩余大小，ACK后尽快清空发送缓冲区

重传机制特性
超时重传
快重传（立即重传）：接收方确认机制变成每一个报都ack 不推迟，立即重传，发送方接收到四个确认号相同的ACK，重传确认号后的内容
超时重传就像ip路由协议里的GBN，快重传就像SR协议

流量控制
服务器和客户端都维持一个发送缓冲区，一个接收缓冲区，对于一方到另一方的通信，建立发送缓冲区和接收缓冲区，发送缓冲区存储已发送未确认或者未发送的数据，需要及时右移剔除已确认数据，且发送窗口大小随时根据接收者剩余缓冲区大小调整，接收缓冲区接收到的顺序数据应该尽快交付

TCP拥塞控制
口诀 慢开始 拥塞避免 拥塞解决 快重传 快恢复
相关概念 
拥塞窗口阈值 拥塞窗口（发送窗口）
怎么判断网络拥塞？ 如果ACK超时 则严重拥塞  如果连续收到4个相同ACK 则有点拥塞 拥塞严重时候执行拥塞解决算法 拥塞轻微时使用快恢复算法
发送方维护一个发送窗口（拥塞窗口），起始时，发送方采用慢开始算法，cwnd大小为1，然后每次收到ACK后立即*2（指数增长），直到达到拥塞窗口阈值，改用拥塞避免算法，改为线性增长（每次加1），且线性增长阶段单RTT内收到多次ACK，也只增长1，每RTT最多增长1
如果有ACK超时，说明网络严重拥塞，马上采用拥塞解决方法，cwnd改为1，拥塞阈值/2（乘法减小），然后继续慢增长
如果有连续4个相同ack收到，执行快恢复算法，cwnd 和 拥塞阈值同时改为 (cwnd/2), 然后继续使用拥塞避免模式

WWW 万维网
包括 URL HTTP HTML
URL = 协议+主机+端口+路径
HTTP协议分为非持续连接 和持续链接 非持续连接每次传送一个资源重新建立连接 持续连接分为流水线 非流水线连接 流水线同时发送多次资源请求 非流水线单次发送，但是不关闭连接 在html文件体现为connection字段为close 和 keep alive
http 1.0 默认非持续连接
http 1.1 默认持续连接

## 计网错题
<img width="821" height="177" alt="image" src="https://github.com/user-attachments/assets/c9bcf2bb-58a6-4458-b6a0-0e71d494d07a" />
理解RTT发送多少次数据出错
