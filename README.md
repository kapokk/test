408中地址都是从0开始，涉及有多少个元素的问题要区分好下标，长度，元素个数，偏移量
两个下标相减，得到的是偏移量，偏移量+1才是长度，元素个数等于长度而不是偏移量（b-a得到的不是元素个数而是偏移量）

# 语法
C语言进制转换：两个原则，1.符号扩展（符号位为1，补码补1，符号位为0，补码补0 2.无符号和

# 数据结构
## 一阶背诵点
逻辑结构分为四中，集合，线性结构，树结构，图结构 ；
物理结构：顺序结构 链式结构 索引结构 散列结构 块结构



循环队列
尾进头出
rear 指向下一个元素插入的位置 front指向下一个出队元素的位置
队满：rear+1)%max = front
队空：front = rear
入队要判满
出队要判空

## #树相关  

树的基本量  

层数，高度，深度都是蹭1开始  

层数从1开始，     高度从1开始，高度方向从叶子往根， 深度从1开始 方向从根到叶子  

树的高度计算 左右子树的最大高度+1

﻿树的性质

﻿节点个数与边数的关系

    n = e+1

﻿节点总数和高度的关系

﻿    n = m的n次方－1 比上m－1 m是度数

﻿   对于二叉树就是2的n次方－1

﻿

不同节点度的关系  

对于二叉树 n0 = n1+n2  

﻿

﻿h层有多少个节点

﻿n＝m的h－1次方

﻿

﻿n个节点树的最小高度

h ＝log_m (n(m-1)+1)

树，森林，二叉树互转

### 树算法
每个算法包含以下内容，算法用途，算法解决情况，操作，起终条件，时间复杂度，

#### 线索二叉树
概括：利用左右子树为空的节点来存放前驱后继
#### 平衡二叉树
平衡二叉树用于减少搜索树时节点的遍历次数

操作：
	平衡二叉树查找
		
	平衡二叉树插入

	平衡二叉树删除

#### 红黑树
也是搜索树效率优化，树的平衡维护比平衡树方便

#### B,B+树
也是搜索树
分叉树m－1为关键字数，关键字数要>(m/2)向上取整 再减1
对于任意子树，子子树高度相同，所有失败节点都是叶子节点
对于B树，根节点可以只有两个节点，其他节点都要有至少(m/2)想上取整个节点
n个关键字的b树有n+1个失败节点，n+1>=第h层节点

B树的插入：看B树的最底层节点 查找插入到最底层 如果插入后此层关键字数没有大于m－1，则无需后续处理，否则取中间节点放入父节点，同时这几个节点分裂成两部分，如果父节点继续满，就继续分割分裂

B树的删除：查找要删除的节点，删除，然后找到这个节点的直接前驱或者直接后继代替该节点，取出节点的层发生变化，如果大于m/2 - 1 ,无需操作，如果小于，把父节点的关键字拉下来，从左右相邻的兄弟节点前驱后继关键字代替父节点的位置，但是如果左右兄弟都有临界个关键字，则把父节点拉下来，然后合并左或右兄弟，此时父节点少了一个关键字，如果小于临界，继续把他的父节点拉下来合并



#### 哈夫曼树
生成最短长度编码，节点带权路径长度（WPL）最短的编码：
构造方法：
	所有带权节点独立分布（单点树森林)，寻找根值最小的两个树，汇合成一根
	重复上述步骤直到只有一棵树


哈夫曼树生成的编码是可变长编码，同时是非前缀编码（每个编码不是另一个编码的前缀）
但是可变长编码对应的是前缀编码，这样在解码的时候就会有歧义，这种前缀编码在二叉树几何上体现为非叶子节点参与编码元素的构成；非前缀编码则只有叶子结点参与编码


#### 树的并查集
并查集的表示：
维护一个数组p，数组的长度为元素的个数，初始化时数组所有元素为－1，当元素的值大于0时，数组的每个值的意义是父节点的索引，当元素的值小于0时，元素的绝对值表示当前集合的节点数

可进行操作：合并 ，查询所属集合.   

查询：循环，判断p[i]是否>0，是则继续，否则找到了集合根节点；；；查询算法的优化思路－>路径压缩

合并：输入为需要合并的两个集合的根节点，如果p[r1]==p[r2]，则不操作，如果p[r2]>p[r1]，即树2的节点树比树1的多，则小树并入大树p[r1]=r2，p[r2]+=p[r1](更新节点数)，如果p[r1]>p[r2],即r1集合的节点更多,p[r2]=r1,p[r1]+=p[r2]


#### 拓扑排序
用于AOV（DAG）的寻找做事的先后顺序
流程：寻找入度为0的节点，令其子节点入度减1，然后循环直到没有节点

#### 关键路径
AOV中，节点称为事件，边称为活动，
关键概念：寻找活动余量为0的事件
需要求ve,vl,l,e
活动余量公式=l-e


KMP
nextj数组从1开始存，0不存东西
字符串T从1开始存东西，0存长度
next[1] = 0 next[2]=1


# 栈

应用
中缀转前缀表达式
右优先原则（从右往左读）确定符号优先级，然后一次拼出前缀表达式
中缀转后缀
左优先的原则（从左往右读）确定优先级，然后拼出后缀
后缀转中缀
从左往右扫描，数入栈，遇到符号，弹出两个数转中缀，先弹出的是右操作数
左优先右优先是指两个符号同优先级时先算哪个
转后左优先 转前右优先 （反的）

前缀计算，从右向左扫描，遇到符号弹出数计算，先弹出的是左操作数
后缀计算，从左向右扫描，遇到符号弹出数计算，先弹出的是右操作数


# 图
存储结构：
邻接表：存无向图会有重复
邻接矩阵
十字链表（有向图） Node存firstin firstout ，edge存source，destination，same source next，same destination next
邻接多重表


关键路径求法
求节点最早发生时间，最晚发生时间 然后求边最早发生时间 边最晚发生时间，边最晚减最早时间为0，则有关键路径

左侧节点最早发生时间为0，拓扑排序顺序遍历之后的节点，e(k) = max(v(j)+edge(jk)),j是k的前继节点
右侧节点最晚发生时间等于最早发生时间，逆拓扑排序遍历，l(k) = min(l(j)-edge(jk))，j是k的后继节点
边的最早发生时间等于节点的最早发生时间
边的最晚发生时间等于边末节点权重-边权重

堆排序
1。建堆
大根堆 小根堆
对于每个非叶子节点（<=n/2),选择两个孩子中更大，更小的一个下沉，然后继续检查孩子直到不大于，不小于当前节点
2。交换
交换最后一个节点与第一个节点
3。根下沉
对比孩子，选择更大更小下沉，直到下沉不了
小跟堆得到递增序列 
大根堆得到递减序列

快排
每次确定一个proviot的位置
然后左右分别继续快排

给定low为s[0]，high为s[n-1]，priviot
temp=low,high从右到左扫描，直到temp>high ,s[low] = s[high]
然后low从左到右扫描，直到temp<low,s[high] = s[low]
重复上述两行，直到low>=high,s[low] = temp
然后对low，privot-1 , privot+1,high两个区间递归快排

直觉流程，给定数组，low上提为privot，low为空，扫描high，直到high小于privot，数组low等于high，然后high为空，扫描low，直到low>privot,数组high=high,循环直到high,low重合，一个元素确认最终位置，左右两边递归快排

基数排序
给定数组基数为k,位数为m，建立k－1个队列，扫描从0到m-1位，每次扫描，将扫描到的数放进对应基数队列，扫描完，从0到k－1依次出队，所有扫描完成则有序, 得到递增序列

注意基数是10，则队列生成10-1 = 9


djistra
初始：若从v0开始，final0等于true，dist0=0，path0=－1， 其余定点final为false，dist等于arcs[0）（定点] ，path如果直接和0相连为0，否则为－1

n-1轮遍历
找到final为false的dist最小的定点i，令final等于true，检查所有其邻接的定点j，如果final为false，检查dist[j] 和 dist[i]+arcs[i,j] 如果从i到j的路径小于distj，就更新distj，并且令path[j]=i

floyd算法，建立一个二维dist表，二维path表
dist0表 d[i,j]是i到j的权重，没有就为无限，

然后进行k轮遍历，新建表distk，如果dist[k-1][i,j]>dist[k-1)(i,k) + dist[k-1)(k,j)
则更新dist[k][i,j）为右值，path[k)[i,j)=k
否则保持原值


BFS
用队列

DFS
用栈

# 操作系统

管程 每次只允许一个进程在内操作
管程包括多个方法 和 共享变量 每次只能一个进程调用一个方法 
管程可以wait 变量以实现同步 wait时调用者会撤出管程，让出使用权

死锁
注意请求信号量一定要比请求互斥量先执行，释放信号量一定要在释放互斥量后执行，互斥量执行在最里层，否则会死锁
至少两个进程出现互相等待对方资源的情况
死锁产生的必要条件：1.资源互斥 2.请求新资源却不释放资源 3.几个用户同时等待同种资源 4.没有外界干预他们的等待（不剥夺）
其中一个不成立，就不会有死锁
解决死锁的思路有三种 消除死锁产生的条件；；；避免死锁；；；检测死锁

避免死锁算法：银行家算法
在每次分配资源前检查此分配是否会导致系统不安全
有m个进程，n个资源，1.维护一个m行3列的表，第一列是进程最大资源需求 第二列是已分配资源向量 第三列是进程最多还需要资源（最大量-已分配）；；；2.维护一个剩余资源向量；；；3.维护一个进程请求向量
然后进程请求资源时执行以下操作
1.检查如果分配了资源请求是否到达进程最大需求，是则跳出
2.需求资源是否小于资源存量，否则退出
3.更新已分配资源（加上请求资源）和资源存量（减去请求资源）和进程还需要多少资源（减去请求资源）
然后对于所有剩下的资源，寻找需求量少于存量的进行满足，就是修改剩余资源为当前剩余资源+已分配资源，并把当前进程加入安全序列，后续扫描屏蔽这个进程表量
重复上述直到不满足或者全满足后 判断安全序列是否为所有进程，如果是 则分配可以进行，安全，否则不安全

解除死锁算法
系统维护一个图，记录进程和资源分配情况；；有两种节点 两种边 资源节点和进程节点 ；；；请求资源边和分配资源边
检测死锁有没有发生：
1.找进程节点，找进程节点请求边对应的（除去分配边和请求边后资源仍有剩余的）资源节点，此时删除进程节点的所有进边和出边
2.循环这个过程，直到找不到符合条件的节点
此时 如果图完全没有了边 说明没有死锁 否则 有边的节点就有死锁

死锁处理策略
1.挂起死锁进程
2.关闭死锁进程
3.死锁进程回退到没死锁的状态
处理优先级：
进程优先级，已运行时间，还要多久能完成，已使用资源，交互式进程还是非交互

-----
内存与进程运行
程序封装成可执行文件装入内存运行，可执行文件包括程序段和数据段
可执行文件可以是单程序 ， 程序+静态链接库 ， 程序+动态链接库
单程序，编译链接阶段就写死了程序段和数据段，直接装入内存运行
程序+静态链接库，装到内存前先链接在一起再装入内存
程序+动态链接库，程序先装入内存，在需要动态链接库时再装入到内存，同时操作程序中的相关操作地址，地址可不连续

进程装入内存也有三种方式
静态装入，指定死装到内存的哪里
运行前链接然后装入，程序里存在的是对数据逻辑地址的操作，装入时指定数据段起始地址从而进行地址重定位
运行后链接然后装入，运行时装入数据后把数据地址保存到重定位寄存器，然后重定位逻辑地址为物理地址

运行后装入需要对程序进行地址重定位，把逻辑地址转换为物理地址运行

内存保护（防止进程越界访问内存）
1.设置进程内存上下限
2.设置重定位寄存器 和 界寄存器（存储最大逻辑地址）
注意逻辑地址是从程序指令段起始开始而不是数据段起始开始。

进程是内存分配管理的最小单位 不能把进程（程序）内的数据段拆分，碎片化
进程在内存内的映射 程序段， 只读数据， （静态变量，全局变量），堆（malloc），共享库函数，栈（记录当前运行步骤信息和局部变量）

内存分配，内存分区分配
内存分配分为连续内存区域分配和不连续分配
连续分配：：
         （维护一个分区表，包括分区号，大小，起始地址，状态）分区表只能看出空闲内存信息，已分配的进程是不包括在分区表中的？，进程分配后，重新计算该分区的起始位置和大小，更新
         1.单一分配 2.固定分区，分区大小固定或不固定  3.动态分区
         固定分区和单一分配有内部碎片
         动态分配有外部碎片
         动态分配内存可合并，相邻内存段合并成一段，
         动态分配的四种方法
         1.最近分配 2.最小大小分配 3.最大大小分配 4.就近分配
         最近分配查询开销小
         最小大小分配会导致很多细小碎片
         最大大小分配会使大内存被很快用完
         就近分配也会导致大内存快被用完，但是他的查询开销小
不连续分配
         分页分配
                  相关概念：分页 页大小 逻辑地址 物理地址 页号 页内偏移
                  把内存分为固定大小的页，然后进程的可执行文件同样按照固定大小分页，程序分页后乱序装入内存中，同时维护一个进程页表（在PCB中存页表存的地址和页表长度）
                  ，存储逻辑页号和物理页号的一一对应关系 ；；；因为页表逻辑序号是顺序的，直接用数组下标表示逻辑页号，用元素值表示物理页号
                  此时就要把逻辑地址转成物理地址，当程序访问某块地址时，求逻辑地址对应的物理地址再访问
                  求法：物理地址 = 页初始地址+页内偏移
                                 = 逻辑页号对应物理页号 * 页大小 + 页内偏移
                                 = 逻辑地址整除页大小向下取整（得到逻辑页号）-》对应物理页号 + 逻辑地址%页大小（页内偏移）
                                    实际计算机算页起始地址和业内偏移是直接二进制掩码来取的，页大小占几字节，剩下的位数就表示片号
                  相关计算：一个页面大小为4KB，有2^12次方B，至少需要12b来表示（不过系统一般分配B的整数位来存页内偏移），假设系统字长32位，剩余20位可以用来表示页号，可表示2^20次方个页号
                  地址重定向：
                           程序运行前，从进程PCB里读取页表物理起始地址和页表长度到寄存器，然后当进程意图读取内存时，将逻辑地址转换为逻辑页号和页内偏移，首先检查逻辑页号是否大于页表长度，然后继续（页号+页表初始地址）得到逻辑页号所对应的物理页号，然后*页长得到物理页地址，然后+业内偏移读取到最后内存
                  --------
                  二级分页
                  给分页再分区间（目录），这样分页表的部分数据就就可以不用常驻内存
                  多级分页中各级目录表示位数不得大于页大小，因为大于页大小，表示的分页就超出了实际最大分页数
                  易错点：页号从0开始，如果页表长度位8，则可表示0-7，而不是0-8；；可表示数=右下标-左下标+1 = 长度+1
                           页大小为1K 那么物理页1的初始地址 = 1*1K 不是一千！！而是1024 ，业内偏移=逻辑地址%页大小 通常逻辑地址单位是B ，页大小要转为B 比如1K转1024B 不是1000B
                           页表内的块号大小取决于内存大小和页大小，需要表示这么多页，而块大小就是页面大小
                           名词区分：页面是一个分页，页框也是一个分页，页长度是分页长度，页表项长度是页表里的每一项的长度（需要符合能表示内存内所有页序号）
         快表
                  把分页表一部分克隆到TLB（一种缓存）中，进程访问内存时，优先查快表，拿到分页号和业内偏移之后，在快表找页号（快表的页号是有页号字段的），没命中把这个分页表段加入快表，然后查内存分页表，
                  局部性原理：程序的运行有空间局部性和时间局部性，程序的代码段可能在短时间内再次运行，访问过的内存可能再次访问，所以把他加进块表中
                  有的系统支持同时查快表和内存，此时如果快表没有命中 ，耗时是（查快表耗时+访问内存耗时）*命中率 + （两次访问内存耗时）*非命中率
         分段存储
                  分页是页大小均分，分段是段大小不均分，是根据逻辑分段的（比如函数作用域内分一段）
                  分段可以更好实现不同进程间 不同子函数间的信息共享 比如两进程调用同一方法，只需要指针指向共享方法的地址即可，如果用分页，额不知道为啥不行
                  分段对用户可见（汇编层？）
                  -----
                  具体实现
                  维护一个分段表，索引表示分段号，有两各元素，段起始位置和段长，PCB中存储分段表起始地址和分段表长
                  进程的地址存储方法有所改变，是逻辑分段号+段内偏移
                  进程读取内存时，提取内存的逻辑段号和偏移，判断逻辑段号是否大于段表长，然后段表起始地址+逻辑段号，得到逻辑段号对应的表项，判断偏移是否大于段长，否则段起始地址+偏移取得内存
         ----
         段页式存储
                  分段后每个段内再分页
                  此时段表存储段号（索引），页号，页长度，，，页存储页号（索引），内存块号
                  实现了段内资源无碎片

虚拟内存：
         包括页面请求算法和页面置换算法
         首先要修改页表结构，包括页号，内存地址，外存地址，是否在内存中，访问字段，修改字段
         页面请求，扫描页表，判断是否在内存中，不在则触发缺页中断（cpu fault中断），如果内存没满等待io复制号内存后唤醒，
         如果内存满了，页面置换，置换一个现有内存页（如果修改位没变不用换），调用设备io
         注意页面请求和页面置换时分别要页表段加入和删出快表
         ---
         内存置换方法
                  1.FIFO 先进先出 不好用
                  2.最近时间没用的先出
                           页表访问字段放最近调用时间
                  3.时钟置换算法
                           把该进程的页表段连成循环链表（就像时钟），然后每一轮扫描360度，扫描多轮来置换
                           原则是选择最近没用到的页面进行置换，访问字段位0没用，1用了，每轮扫描扫描到的访问字段归0
                           选择0的出
                  4.改善时钟置换算法（加了修改位的判断）
                           扫描有变化
                           第一轮扫描访问0，修改1的出去，没有进行第二轮
                           第二轮扫描访问0，修改0的出去
                           第三轮0，1
                           第四轮，0，0
                           性质决定了最多扫描四轮
         内存文件映射：
                  文件放进虚拟内存里

文件存储（文件是操作系统重点）：
         文件逻辑上：分为无结构文件和有结构文件
                  有结构文件有三部分组成：顺序文件，索引文件，索引顺序文件
                           顺序文件分为定长记录文件和不定长记录文件，定长文件顺序存储可以随机访问，链式不行，不定长记录文件不能随机访问
                           索引文件就是指向逻辑文件块的表
                           索引顺序文件是索引文件的优化，索引与文件块之间不再一一对应，而是一个索引对应一组条件划分的文件块区的起始逻辑地址，使得索引空间缩小
         文件物理上：
                  三类：顺序结构，链式结构，索引结构；；；链式结构又分为显式链接和隐式链接
                  顺序结构即文件存储在磁盘块里面，不方便增删，但是方便顺序读写和随机存储，只需FCB给定起始物理块地址+长度即可遍历
                  链式结构：
                           隐式链接：链接存在块中，访问时链接下一跳，需要多次磁盘io，不方便
                           显式连接（全局索引）：整个磁盘维护一个文件链接表（FAT），索引表示物理块号，元素表示下一跳索引地址，这个表在内存中维持，就不用频繁io
                  索引结构（文件内索引）：
                           显式链接是全局索引，整个磁盘只维护一个索引表
                           这里的索引是指文件内索引，文件维护索引表（单，多个），此时FCB里存储存储的起始物理地址是索引表的起始物理地址
                           索引有链接索引，多级索引，混合索引，后两个，索引表的最大长度都不能超过一个磁盘块的长度（否则会越界）
                           索引的序号表示逻辑块号，内容表示物理块号
                           链接索引就是本来索引放在一个物理块上的，但是文件块数量（系统给出）大于索引能表示的长度，这时就留最后一点空间存放索引下一条；；；单块存储索引时，最大索引表长度 = 空间大小/块大小
                           多索引非最底层索引存储的是下一级索引表的地址，如果给定一个逻辑地址要查找，则逻辑号/i级索引表长度作为i级索引号前往下一跳，达到最底层索引时逻辑号%索引表长度得到最后索引跳向物理块号
                           混合索引：索引表前几个直接指向物理块，后几个一级索引，再后几个二级索引
                           -----
                           考点：
                                    1.根据索引结构计算最大存储长度
                                             如果是直接索引（链接索引），文件块数=索引表长度
                                             多级索引，文件块数=1级索引表长度*i级索引表长度...
                                             混合：两者混合
                                    2.磁盘io次数，链接索引要访问逻辑块号/索引表长度次；；；多级索引需要访问k级+1次io
         ------
         文件目录：
                  目录存储的是FCB（文件信息），FCB包括文件名，文件大小，权限，物理地址等信息
                  目录单级目录不支持同名，多级支持同名，有绝对路径，相对路径
                  还有无环图目录，类似linux的软连接吧，链接目标维持一个引用计数器，当所有引用都消失时，这个节点才会被删除
                  目录索引节点：不再存整个fcb太大了，把除了文件名的内容都放到一个索引节点指针上去
         -----
         磁盘被分成一个个文件卷，卷内有目录区和数据区
         -----
         文件存储管理：
                  分为分配和回收
                  空闲信息的记录方式
                           空闲表，存储空闲块号
                           空闲链表
                                    空闲块链，分配时从链头取，回收时从链尾取
                                    空闲区链，每个节点存储块号和区长，
                           位图法 二维数组表示空闲区块 行为字，列为字内偏移 i,j对应物理块号是i*字长+字内偏移；；；这里i是字数，从0开始，如果从1开始，表示字编号，要i-1 再 * 字长算偏移（0，1容易错）
                           成组链接法（适用于大型文件系统），维护超级表结构链（存在文件目录里），每个超级表是个数组，第一行存表长度，后面元素放空闲块，然后每个空闲块连接下一个超级表
                  文件的操作
                           系统会维护一个打开文件表，存储正在打开的文件，维护一个打开数，表示当前有多个进程打开，用户关一个，减1，为0则移出打开表
                  文件共享
                           硬链接：存储在目录索引表的索引节点中（索引表分为文件名，索引节点），索引节点维护一个链接数，多文件链接，如果链接源头被删除，不影响链接
                           软连接：目录索引表里的索引节点内放的是软连接文件的块号地址，磁盘io发现是软连接文件还得io一次，耗时长，源文件被删除，软连接还存在（硬链接源文件删除就不存在了？）
                  文件访问控制：
                           文件FCB里有个访问权限区
         虚拟文件系统：
                  不同的读取方式的文件系统的集成（UFS,FAT)，提供统一接口

IO设备
         IO控制器
                  io和cpu交互的核心，结构上有数据寄存器（io数据），状态寄存器（设备工作状态），控制寄存器（控制目标地址信息），数据总线（与前三个寄存器通信），地址线和控制线
                  cpu要操作io寄存器，就要在内存里给寄存器映像编址，编址分为内存编址和寄存器独立编址
                  每个控制器可以控制多个设备，控制器统一由通道管理
         IO控制方式
                  程序控制，中断，DMA，通道
                  中断控制只能传输一字，DMA能传输多块（物理连续），通道能传输多组块
                  中断每次数据就绪触发中断，DMA，通道也是，不过更加灵活；；通道能使用内存中的通道程序对io进行复杂操作
                  cpu干预率四者降序，中断率降序排列
                  每次中断cpu都有保存环境开销，索引中断越少越好
         io程序架构
                  操作系统内核有专门的io核心子系统，其架构为：设备层；驱动层，中断层，硬件；；；用户调用设备层接口、
                  设备层负责：提供接口，差错控制，设备保护，设备分配和回收，**缓冲区管理**，逻辑设备与物理设备的对应，调用驱动；；；；；设备层维护一个逻辑设备表LUT负责映射关系
                           设备映射：每个用户维护一张LUT，分配给进程PCB，lut内容有：逻辑设备，物理设备，对应驱动进程地址（驱动程序作为进程）
                  驱动层负责：寄存器处理等io的具体实现
                  中断层：处理中断，异常处理，寄存器数据复制到内存
                  硬件：控制io控制器
                  ---
                  在用户和设备层之间，设备层提供统一的接口供用户使用，分别是：字符设备接口（不可寻址），块设备接口（可寻址）和网络设备接口
                           其中网络设备接口是套接字接口（socket），需要绑定本地端口，配置连接的网络
                  设备层和驱动层之间：操作系统为不同设备提供了一定的标准，各厂家编写驱动要符合标准才能被使用
                  用户调用设备由分为阻塞io和非阻塞，阻塞io要阻塞进程等待唤醒，非阻塞可以连续操作
         io程序细节
                  易错点：假脱机技术（spolling）是在用户层实现的
                  设备层负io调度分配，文件保护，缓冲区管理
                  ----
                  假脱机技术的实现
                           假脱机技术缓和cpu和io的处理速度矛盾，同时允许程序共享设备
                           需要输入输出的数据，先放内存里的输入输出缓冲区，缓冲区再慢慢发给输出设备
                           可以缓冲不同的程序的输出，形成队列，分批发送
                  设备分配细节
                           某些设备不支持假脱机(spolling)技术，需要系统分配防止资源冲突和死锁
                           系统为每个设备维护一张
                           逻辑设备表LUT，记录逻辑名和物理名，驱动程序地址等
                           DCT表（device control table），记录物理设备号，设备类型，等待使用的进程队列，控制器指针等
                           coct（controller control table），存放状态，通道指针，进程队列
                           CHCT（channel control table），存放
                           ---
                           分配时查找LUT->DCT->COCT->CHCT表，一路非占用状态才能分配
                  io缓冲细节
                           io缓冲在内存里，减缓cpu，io的速度矛盾
                           缓冲区特性：
                                    只有为空才能写数据，只有满才能读数据，缓冲区默认大小是一个块
                           缓冲区程序流程：
                                    设备->缓冲区->工作区->cpu (反向亦可）
                                    常考题型：
                                             缓冲区算耗时（默认假设初始状态是工作区满，缓冲区空）
                                             单缓冲区
                                                      假设设备到缓冲区耗时db,缓冲区到工作区耗时bw,工作区给cpu处理时间wc
                                                      开始运行，cpu处理工作区数据，同时设备向缓冲区发数据，然后缓冲区传给工作区，然后cpu处理工作区数据，同时缓冲区接收，如此往复
                                                      假设cpu处理时间大于设备到缓冲区时间，那么平均处理需要时间wc+bw
                                             双缓冲区：
                                                      设备存完一个马上存另一个，效率更高，平均处理时间更短
                                                      双缓冲区能全双工通信
                                             循环缓冲区
                                             缓冲池
磁盘
    关键词：柱面号（磁道号），盘面号，扇区号，扇区大小，数据密度，多磁头，磁盘调度算法，响应率，转速，启动时间，延迟时间，交错编码，固态硬盘损坏时长，寻道时间，延迟时间，传输时间
    请求耗时等于寻道时间+延迟时间+传输时间
    寻道时间是磁头从磁道移到另一个磁道的时间，分为启动和移动
             移动时间=移动速度*跨越磁道数
    延迟时间是旋转到固定扇区所用的随时间
             移动一个扇区耗时=（1/一转扇区数）/转速
             平均延迟时间等于（1+N)/2 * 移动一个扇区耗时
    传输时间是走对应数据，扇区所需要的时间
             传输时间等于移动扇区数量n/(N) /转速
    FCFS
             先请求先服务，训道时间长
    SSTF
             最短寻道时间优先
             寻道时间短，但是容易饥饿
    SCAN
             扫描，每次只有扫描到边界才能转换方向，响应时间均衡，但是容易多走道
    Cscan
             循环扫描，每次只有向外走的时候会处理请求，走到最外面反向回0时不处理请求，平均寻道时间更长但是平均响应时间更短
    LOOK
             磁道方向转换的条件改为走到请求中磁道最大最小处就转
    Clook
             Cscan的改进，不再走到边界才回头，没有后面的请求就回头
    交替编号
             背景：每读完一个扇区磁盘由处理时间，此时磁头不能读其他数据
             在同一个盘面内，为了减少走到对应扇区的延时时间，本来逻辑扇号对应的物理扇号是连续的，现在交替编号，逻辑1对应物理1，逻辑2对应物理3，这样读了一个扇区，留一个扇区的时间给硬盘处理，在读下一个扇区
    错位命名
             背景：每读完一个扇区磁盘由处理时间，此时磁头不能读其他数据
             在同一个柱面内，盘1读完最后一个扇区7，下一个要读柱面2扇区0，但是原编号导致7和0相邻而读完扇区处理需要时间，就错过了，柱面间扇区编号错位可以解决这个问题
    坏块管理
             系统维护坏区表在FAT
             磁盘内部管理坏区，使用备用扇区代替
                                    
## 操作系统错题

操作系统和中断是两个独立的个体，共同操作cpu，中断时PSW的存储和内核态都是终端完成的，不是操作系统完成的

<img width="908" height="256" alt="image" src="https://github.com/user-attachments/assets/323b5975-0104-435a-a3f7-511ed8d3d3d8" />

创建进程是高级调度完成的，进程管理是低级调度完成的

注意区分 前 后这些时间介词易错点
         
# 计算机网络


犯错：：：
3bit能表示多少个数？ 2的三次方个 ；；但是最大表示值不是6 是2的三次方-1


浮点数存储
符号位 尾数 和阶数
尾数默认为1xxxxxx 所以第一个1省去 实际上只存储xxxxx，还原时记得加上，这里存储的是二进制真值

阶码用移码存储表示 阶码十转二 
十进制下表示二进制小数点移动的位数（移动到小数点前只有一个1）阶数 + (2^8) -1(阶数位【float为8】)，然后再转成二进制，所得的就是移码

移码2转10：
二进制按照十进制解读，然后减去2^n ) -1 得到的k就是2的k次方

尾数二转十
尾数最左端补1,然后小数点从最左端1后面移动阶数位（阶数是2的n次方的n转成移码，需要还原），然后再转10进制，小数点后二分之一四分之一六分之一....

十进制小数转二进制
乘基取整法 *2 取整 剩下的位继续*2 知道小数部分剩下0

补码转原码（负数）
除符号位取反 然后加1 （不是减1）
原码转补码 （负数）
除符号位取反 加1

浮点数的特殊值
阶数全0 尾数全0 是正负0
阶数全0 尾数不为0 非规格化数 转十进制 ： 尾数位最左边补0（0.xxx）然后算出十进制 再*2的-126次方
阶数全1 尾数全0 正负无限
阶数全1 尾数不为0 NaN
求表示范围时注意阶数位不能全0 全1

多路选择器的控制信号位数
选择k路 则需要log2 k 向上取整个信号

组成原理看到浮点数

数据结构：

二叉排序树没有值相同的节点
平衡二叉树的插入，删除，平衡
插入小于向左大于向右 插入到根节点
删除：1，待删除节点的直接前驱，直接后继，没有就直接删除 2，替换直接前驱后继和待删除节点的位置 3， 删除待删除节点（此时在叶子处） 4， 寻找最小不平衡二叉树，调整直到平衡
旋转：
前置知识：因为平衡因子为正负1时，树平衡，要不平衡至少为2，所以寻找最小不平衡二叉树，寻找平衡因子为2的最小子树
寻找最小不平衡子树，如果为往下看成因，看哪边高，往下找两层，看是LL,RR,LR,RL ,LL 的L节点往右旋，RR往左，LR先左再右，RL先右再左，然后递归网上查找不平衡 lss




计算机网络（经常需要B,b,之类的单位转换）
在计算机网络中M,G,T的值是10的369次方，和其他科不一样

Internet是互联网  inter是局域网 局域网不限协议 互联网是tcpip
通信方式：电路通信，报文通信，分组通信，电路通信直接但占据链路，报文通信没有差错纠正，

网络性能指标
带宽 信道最多每秒传输多少比特 b/s
时延带宽积 信道传输时间*带宽 表示最大信道容量
时延 对于单个比特或者报文通信模式 发送时延+传输时延；；；对于分组通信模式需要画时序图来求和，不是简单的累加，时序图每条线表示一个节点，然后在上面画平行四边形，画法：数据从最左边竖线出发，先确定竖边长度为分组数据量/发送速率，然后看下一跳线，向下走传输时延的长度，画发送时延长度的线，然后封闭两条线为平行四边形，这是一个分组，下一个分组紧随其后，用相同的做法画，最后计算整个竖线耗时，发现时延不是（发送时延+传输时延）* 分组量【因为中间传输时延不是累加关系】
RTT：从一个分组发送完成后开始，到接受完确认消息结束，中间的耗时是RTT
吞吐量：传输时间/总时间



信道性能指标：
带宽：波形频率，单位HZ
码元：1个周期的波可以表示多少种信号
码元比特转换：k进制码元 就是log_2^k个比特
波特率：码元/秒
比特率:  比特每秒  k进制码元每秒 = log_2^k比特每秒
信噪比/分贝信噪比 :信号功率/噪声功率,这是信噪比，没有单位，分贝信噪比：10log_10^(S/N) 这是分贝信噪比 数值表达范围更窄；；注意做题时分辨题目中的信噪比是有单位信噪比还是无单位，算法不一样，有单位还要转换为无单位才能算香农

理想最高波特率：2W,W是频率
噪声信道最高比特率 KW*log_2^(1+S/N)

注意理想信道公式算的是波特率，噪声信道最高比特率算的是比特率

网络分层模型
OSI模型 ， TCPIP模型，教材模型
教材模型：物理层，数据链路层，网络层，传输层，应用层
OSI：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层
TCPIP模型：网络接口层，网络层，传输层，应用层

OSI模型网络传输层和tcpip网络传输层的差别：
OSI模型网络传输层进行差错控制可靠传输流量控制 TCPIP的不进行差错控制可靠传输流量控制
UDP属于传输层的内容

奇偶校验码
	保证数据+校验位中1的出现次数位奇数或者偶数的校验码
	校验码值：如果数据有偶数个1，奇校验码为1，有奇数个校验码，及校验码为0，偶数则相反
	易错点：奇校验码只能检验奇数位错误，偶校验码只能检测偶数位错误（然而数据部分奇校验码要求有偶数个1，校验位才为1）

循环冗余校验码的算法
基本元素：数据是待封装成循环冗余校验码的，通信双方商定一个生成多项式，循环冗余校验码分两部分1。数据部分 2.校验码
发送方校验码的计算
1.根据生成多项式P(X^n)构造除数，比如x^4 + 1对应的除数就是10001
2.数据扩容，在低位补0，补0的位数是除数的位数 ；；； 同时校验码的位数是除数位数-1
3.进行一个特殊除法（异或除），其中得到的商不重要，不计算商，只关注余数
         除数右对齐，对齐到除数对应被除数首个不为0的元素
         进行异或运算，同0不同1
         得到的运算结果继续作为被除数进行异或除，如果被除数长度不够，就在根被除数上拉几位下来
         （终止条件是除法结果小于除数位数，并且根被除数没得借了）
         终止的除法结果就是校验位
4.把校验位加到数据低位，组成CRC校验码

接收方数据检错
用CRC码异或除约定生成多项式，直到终止时得最终商
商为0，正确，不为0，错误

海明码校验位数计算：校验位数 = 数据位数+1

可靠传输和流量控制 通过滑动窗口传输方法来实现，即重传ARQ协议
前置概念：丢序，数据帧，应答帧，超时重传，帧编号，滑动窗口n的长度 
帧编号：2^n>= 发送窗口+接收窗口（否则会出现新帧和重传帧重复不能识别的问题）
可靠传输和流量控制得实现要解决：数据帧丢失，应答帧丢失，数据帧出错，数据帧重复问题
停止等待协议（SW协议），发送方和接受方窗口大小为1，编号长度为1b（表示2个编号），发送方发送数据帧，接收方接收数据帧判断帧序号是否在滑动窗口内所需的阵序号内，校验是否通过，如果是则发送ACK，如果不是则不响应；；发送方超时没有收到应答帧重传

后退N帧数协议（GBN协议），发送窗口为N,接收窗口为1，发送方持续发送N帧数据，接收方接收数据返回ack，如果同时接收到N帧数据，则返回最后的有效数据的ACK，如果数据在接收者滑动窗口所需序列号之外或者校验未通过，则该数据无效，发送方如果第i帧超时没有收到ACK，则重新发送i和之后所有帧，如果接收到ACKi，说明i和之前的所有帧都传输完了；；；当数据帧丢失时，没有应答数据帧会超时，会发超时帧和之后的帧；；应答丢失也会重发；；；

选择重传协议（SR协议 select repeat）
发送窗口N,接收窗口m，m<=n,发送窗口内每一帧，接收者每一帧ack，发送者每一帧超时没有收到ack重传，收到NAK否定帧重传，最左边帧确认后，发送窗口右移

可靠传输的信道利用率
发送窗口内所有数据时延/（发送到返回完第一个确认帧数的时延）
发送到返回完第一个确认帧数的时延 = data发送时延+数据传输时延*2 + ACK发送时延    ‘；；；； 对于重传和N帧数后退，信道利用率=NTD / (TD + RTT +TA)
信道利用率可以算最大通讯速率

码分复用和正交
每个站点维护所有站点的码片序列
发送发发送1，就发送自己的码片，发送0，就发送自己的码片取反
因为码片间正交，自己线性相关，接收方收到信号后拿信号S和各个码片相乘，就能得到对应站点发来的信息

可靠传输+冲突解决
aloha 立刻发送 随机重发
坚持监听csma 非坚持csma p坚持csma  及其优缺点
监听csma 监听为空，立即发送，发送失败随机重传
非坚持，监听为忙，随机时间后监听
p坚持csma，监听为空，p概率立即发送，1-p概率等待一段时间后继续监听

CSMA/CD协议
这个协议无冲突认为成功，不ACK
口诀 先听后发，边听边发，冲突停发，随机重发
概念：争用期，二进制指数退避算法，最大最小帧长，冲突检测分辨率
争用期：两倍最远单向传输时延
随即重发 等待时间为 r* 争用期 r的取值范围 取决于冲突次数，冲突小于10次 ，r属于(0,2^k -1) ,大于10次(2的10次方-1)
10，16
接收方处理
最短帧长 2*传播时延*带宽，小于这个视为无效帧
以太网最短最长帧长 ，64B,1518B，最短帧长可以推断出RTT
接收方帧处理 判断帧长丢弃，
最长冲突检测时间等于最长节点往返时间
<img width="769" height="89" alt="image" src="https://github.com/user-attachments/assets/b8592178-a095-443d-a557-ed98b39862be" />
以太网题隐含RTT



CSMA/CA
口诀：发前监听，空闲间隔一段时间发，不空闲随机退避，退避使用随即退避，注意退避时会持续监听信道，只有信道不空闲时才继续倒计时
RTS CTS  请求帧，同意发送帧
DIFS 发送前等待时延
SIFS 接收方处理时延
DIFS > SIFS + 信道传播时延

令牌协议
令牌表示空闲，
令牌帧 数据帧 帧内容 令牌帧使用头尾和令牌号， 数据帧头尾+令牌好+数据+被使用号
令牌环网，小环组成大环
令牌有持有时间 不会饥饿

802.3 802.11局域网 以太局域网
8023是有线局域网 11是无线 以太局域网 MAC帧常规采用以太网的帧

双工通信不需要处理冲突 
无线局域网是星形拓扑结构
有线是总线型
光纤是点对点
MAC在数据链路层

同轴电缆只支持半双工
双绞线支持全双工或者半双工，在设备链接时决定
光纤只能全双工
集线器只支持半双工 交换机支持全双工

MAC地址位数？6B 
MAC帧的结构 662N4(B单位) 注意是先destination再source 然后是协议类型 数据 CRC
MAC发送帧前会发送同步8B的同步信号 是1010101最后是11 11说明开始发MAC 末尾的界定用违规曼彻斯特编码实现 编码使用曼彻斯特编码 （上0下1）
最短最长帧长 64到1500
交换机路由器有MAC地址 集线器没有
广播帧在同一个局域网内才能广播 路由器不转发广播帧
广播的实现 MAC地址全1就是广播
交换机隔离冲突域 路由器隔离广播域

局域网内广播：1 容易广播风暴 2.隐私性不好
引入虚拟局域网vlan
vlan 结构 划分方式 vid
vlan基于交换机实现 同时有基于接口的实现 基于MAC的实现 基于IP的实现
跨交换机通信使用802.1Q帧 6642N4 类似662N4 但是42部分是固定vlan识别号+随机+vid
同一个虚拟网共享一个vid

802.11协议
概念:BSS ESS SSID Portal 漫游 AP 帧分类 帧格式
AP wifi接入点
BSS 一个AP+多台主机
ESS 多个路由器和主机
SSID 服务集的id SS_id
漫游 主机从一个AP到另一个ap
采用802.11帧 有数据帧 控制帧(RTS,CTS,ACK) 管理帧（探测）
帧结构 控制，持续时间，AP MAC，source mac ， des mac 。。。后面省略
地址结构是直接des ， 直接 source，间接des，间接source，直接是指谁发的 谁手的

交换机原理
维护MAC路由表 设定超时丢弃 自动记录MAC对应端口号
转发方式 直接转发 处理MAC帧 662N4里的第一个6 也就是destination
存储转发 存储 差错校验 然后转发

网络层
ip数据报结构
首部+数据
首部：版本，首部长度单位4B,服务，数据报长度（以1B为单位），分片标识，标志位（后续是否还有分片，是否允许拆分），片偏移单位8B，源，目标，可选
注意 除了最后一部分，每一部分数据长度都要是8B的整数倍，最后一部分可以不是8B的整数倍  因为片偏移是8B

注记点：片偏移8B，首部长度4B，总长度1B

ip初版
主机号全0，主机号全1，网络号不为0，分别是表示本网络和网络内广播
n比特主机号能表示2^n - 2 个设备 有两个全零全1不行

子网掩码转发规则
目标ip & 子网掩码后和路由表的网络号对的上，就发

路由器的接的不同子网都要分配一个子网号

注意题型 可分配子网Ip号要减去2，因为全0 全1 不能分配给设备

CIDR划分 ， 变长子网划分
分配方式 从原子网号开始，每次加一位，左0右1，分配子网，剩下的位数-2 就是设备数

0.0.0.0是网络入口IP地址，目标是入口所在端口不转发（没有ip匹配不转发）

CIDR路由聚合 当路由表端口相同且子网号相同则合并 
CIDR最长前缀匹配原则 对于两个相同的ip ， 端口不同，优先选子网号更长的一个

NAT协议 内外网协议 维护一个内网+端口对应外网+端口表 每次穿越内外网边界时修改帧的ip 端口号 是传输层的协议

ARP MAC对应IP 协议有请求帧和响应帧 请求mac全1广播 因为是MAC帧 要符合最短长度 要填充

DHCP协议 是应用层协议 是UDp的应用 基于广播通信
四种帧 发现帧 主动上报mac  提供帧 提供ip地址 请求帧 客户向服务器请求 确认帧 服务器确认ip
四种都是广播 因为DHCp服务器同网络有多个 每个都需要知道i

ICMP协议 属于IP的子协议 封装在IP数据报内 负责报告网络间的一些一场消息
包括终点不可达 超时 参数错误 改变路由 ；；； 还有发请求和发回应（ping） 还有时间戳请求 和应答
对于一些特殊情况icmp不处理 比如来自0.0.0.0,127.0.0.1


IPV6 一百二十八位 用十六进制冒号分法表示 压缩表示：每个段之间前q个0可以省略，再压缩  连续出现的0用：：双冒号省略，但是双冒号只能有一个 ，多个不知道终结缺几个0
有单播多播本地播任一播等 支持新设备直接接入不需要DHCP 直接mac地址


IP路由协议
静态路由
动态路由 RIP OSPF
自治系统 bgp as号 内部网关协议 外部网关协议 自治区平级不包含

RIp
应用层协议 udp传输
有请求帧和应答帧
传输路由表 每个帧最多25个表 要拆分传
路由表格式 目标地址 跳数 下一跳路由器
固定时间交换 触发更新
RIP 十六跳 不可达

RIP的路由表更新
起始 只知道相邻网络的id
然后接收到rip报，进行修改，目标地址不变，跳数+1，下一跳地址改成数据来源
然后和本机路由表比较 如果目标网络是新的 加入 如果目标网络已存在，且下一跳一样 比较跳数 跳数小 更新 ；；下一跳不一样 目标地址一样 更新，以最新的为准

此外 RIP检查下一跳（邻居）150秒内不活着就不可达

RIP的特性
更短路由传得快 路由故障传得慢
RIp还会产生回环 所以用最远跳16来防止回环无线传播

OSPF路由协议
与RIP是应用层的协议不同 这是网络层的协议
包含5种类型数据
问候帧
数据库描述帧
链路状态请求帧
链路状态更新帧
链路确认帧
根据图数据库用djistra算法求到每个节点的最短路径

流程：
开机先检测直连网络
然后泛洪法（不能回流）广播自己的链路数据库
如果链路有变化 立即广播数据表最新
数据帧存储一个序号说明最新消息
支持真假信息鉴别

维护的路由表格式
目标 下一跳 代价 

作为内部路由协议 运行在自治区内 自治区里节点太多 ospf数据库负载大 又继续分区 分为主干区和非主干区 主干区至少有一个自治区边界路由器
分区内有区域内路由 和 区域边界路由

LSDB 链路状态数据库 LSA 链路通告 LSI链路描述信息


UDP协议
结构：源端口号，目标端口号，数据报长度（1B为单位），校验和；；；数据块 数据块受限于ip报数据块大小 65515B（65535-20)
不支持拆分 拥塞控制
校验和的计算：
对首部+数据进行校验和 校验和方法为整个数据报的每16位累加 累加完后取反 得到校验和
接收方拿到数据报后 整个数据报每16位相加 得到结果如果为全1 则正确 非全1 则错误
注意udp校验和计算前要加伪首部（源ip 目标ip 固定模板 udp数据报长度） 然后再校验和计算 发送方接收方都需要先加伪首部
校验和累加过程中最高位产生进位要加回最低位

于ip数据包不同 ip数据包校验和不要伪首部，而且只计算首部校验和 而udp是全数据


TCP协议
四个考点 连接管理 可靠传输 流量控制 拥塞控制
三次交替握手 四次交替挥手
可拆分
TCP数据包头部结构：源端口，目的端口，数据序号（当前报文数据相当于所有数据的第几个字节）seq，确认序号（确认第几个字节前都收到了）ack_seq[ack]，数据偏移（TCP帧中数据在多少个字节后（单位4B），保留，URG（紧急信息，另外编号，编号存在紧急指针），ACK（表示是应答帧），PSH（需要尽快回答），RST（终止连接），SYN（同步中，前两次握手报为1，其他时候0），FIN（1，3次挥手为1，其他为0），窗口大小(rwnd receive window)（确认号算起，接收方还有多大缓冲区,单位KB），，校验和（也要加伪首部），紧急指针（存放紧急数据序号），可变区间（存放单报文最大传输数据量)英文MSS max segment size

注意seq含义是第一个字节是序号几 而ack含义是序号几前已经接收完 也就是ack-1才是接收到的数据最后一个序号


三次握手过程和进程状态转换
1.客户端发送同步请求 syn=1,ACK=0,seq随机一个,ack_seq随便;;；；；进程状态转为同步已发送
2.服务器接收到同步请求 发送同步请求 syn=1,ack=1,seq随机，ack_seq固定是客户端的seq+1,；；；；；进程状态转为信号已收到
3.客户端收到同步请求，准备发送数据了，发送syn=0,ACK=1,seq=服务器同步帧的ack序号，ack是服务端请求帧的seq+1 ;;;第三次握手可以携带数据，如果携带数据，服务器接收到后下一次ack就收成功就要加数据大小（字节）；；；双方进程状态转为已建立连接
建立连接耗时1.5RTT 从开始建立到可以发送数据耗时1RTT

特性：TCP除了握手第一帧ACK为0 知道结束完ACK都为1  
握手建立的23次握手ack都要+1，都消耗数据序号 
挥手13次ack都要+1

四次挥手
FIN交替分别为1,0,1,0 ,收信息者每次都要ack=发送者 seq+1
挥手提出者刚提出还能发一次数据 后面不能发了，如果提出者没有在挥手时发送数据，被动者无需关闭等待直接发挥手3，然后主动者直接发挥手4，注意有个坑，这样的话被动者释放时间就是1.5RTT，主动者释放时间就是1RTT+2MSL 
MSL 是最长报文段时间 系统给定 
挥手过程 A说88，b说收到88了，B说88，A收到88 ，然后A看着B走远，双方收到 关闭
状态发送者先进入FIN_wait1 再进入fin_wait2 再进入time_wait （2MSL）再结束，，接收者先close wait ，lastack，然后close
注意挥手发送者要再见后主动等待2MSL

可靠传输
可靠传输分为确认机制和重传机制
确认机制特性
    延迟确认，确认时寻找最高seq顺序连续的数据的最后以字节的索引设为ack_seq 说明ack_seq前面的所有字节已收到
        如果接收方有数据发送，可以捎带在ACK确认帧中
        如果连续收到两个最大传输长度MSS的报文，立即ACK
        接收完数据之后，ACK时调整接收窗口剩余大小，ACK后尽快清空发送缓冲区

重传机制特性
超时重传
快重传（立即重传）：接收方确认机制变成每一个报都ack 不推迟，立即重传，发送方接收到四个确认号相同的ACK，重传确认号后的内容
超时重传就像ip路由协议里的GBN，快重传就像SR协议

流量控制
服务器和客户端都维持一个发送缓冲区，一个接收缓冲区，对于一方到另一方的通信，建立发送缓冲区和接收缓冲区，发送缓冲区存储已发送未确认或者未发送的数据，需要及时右移剔除已确认数据，且发送窗口大小随时根据接收者剩余缓冲区大小调整，接收缓冲区接收到的顺序数据应该尽快交付

TCP拥塞控制
口诀 慢开始 拥塞避免 拥塞解决 快重传 快恢复
相关概念 
拥塞窗口阈值 拥塞窗口（发送窗口）
怎么判断网络拥塞？ 如果ACK超时 则严重拥塞  如果连续收到4个相同ACK 则有点拥塞 拥塞严重时候执行拥塞解决算法 拥塞轻微时使用快恢复算法
发送方维护一个发送窗口（拥塞窗口），起始时，发送方采用慢开始算法，cwnd大小为1，然后每次收到ACK后立即*2（指数增长），直到达到拥塞窗口阈值，改用拥塞避免算法，改为线性增长（每次加1），且线性增长阶段单RTT内收到多次ACK，也只增长1，每RTT最多增长1
如果有ACK超时，说明网络严重拥塞，马上采用拥塞解决方法，cwnd改为1，拥塞阈值/2（乘法减小），然后继续慢增长
如果有连续4个相同ack收到，执行快恢复算法，cwnd 和 拥塞阈值同时改为 (cwnd/2), 然后继续使用拥塞避免模式

WWW 万维网
包括 URL HTTP HTML
URL = 协议+主机+端口+路径
HTTP协议分为非持续连接 和持续链接 非持续连接每次传送一个资源重新建立连接 持续连接分为流水线 非流水线连接 流水线同时发送多次资源请求 非流水线单次发送，但是不关闭连接 在html文件体现为connection字段为close 和 keep alive
http 1.0 默认非持续连接
http 1.1 默认持续连接

## 计网刷题经验
求网络传输时间，涉及多网段，网段间的数据都是流水线型通信的，要画流水线图，所有分组报的传输时延一般是流水线启动时延+稳定运行时延+冷却时延

## 计网错题
<img width="821" height="177" alt="image" src="https://github.com/user-attachments/assets/c9bcf2bb-58a6-4458-b6a0-0e71d494d07a" />
理解RTT发送多少次数据出错

发送时延一般题中不自动给出，要自己数据量/速率来求

单位换算错误 1Mb/s = 10^6b/s 1MB/s = 2^20B/s 注意不是所有单位都是2^10,位还是按照十进制来算的

<img width="803" height="130" alt="image" src="https://github.com/user-attachments/assets/1760e2d2-a85b-4d66-88dc-aec3dbd8516c" />

<img width="736" height="54" alt="image" src="https://github.com/user-attachments/assets/f55e529d-b2f0-4610-a13f-36ffaa9cf5ab" />

vlan同一交换机下的节点通信不用801.1q帧

不同vlan的主机即使在同意局域网下，也不同相互通信

IP数据报的数据部分长度要是8的倍数（最后一个分片除外）



# 计组

进制转换
         十进制转二进制，短除法，每次除以2然后得到整数放在下面，余数放在右边，然后继续对下面的整数除，直到整数为0就不用除了，最终结果从下往上算，是从整数为1右边的余数开始从下往上

二进制进值转换：有符号和无符号转换，高低位置转换，短转长，无符号数零扩展，有符号数符号位扩展，长转短直接截断，有符号转无符号，直接无符号解释，无符号转有符号，直接转

无符号整数在机器中以补码存储，整数都是补码
算数，逻辑位移，左移溢出，右移丢失精度，算术左移移动后的符号位和原符号位不同，溢出，算数左移低位添0；逻辑左移，遇到1则溢出，算数右移，最高位补符号位，逻辑右移，最高位补0

数据在计算机中的存储：
	对齐方式：
		起始地址%自身字节长度=0，满足则存，不满足地址自增（内容填空）再判断

### 运算电路
双符号位（模4补码），00正数无溢出，11负数无溢出，01正数溢出，10负数溢出，相同无溢出，不同溢出
一个数负数的补码表示：原补码取反+1 

浮点数
         浮点数由符号位，阶数，尾数构成
         float浮点数是1符号8阶数23尾数；；；double是1，11，52
         float偏置127 ， double偏置1023 ， （2^(n-1) - 1 ）
         ---
         真值转浮点数：
                  1.转成二进制
                           整数转二进制：
                                    回忆
                           小数转二进制：
                                    乘2取整法，每次乘2整数部分记录为二进制，取小数部分继续乘，直到小数位为0
                  2.规格化
                           得到xxx.xxxx二进制数，现在调整小数点的位置，使得小数点左边只有一个1，然后省略1，右边的部分计为尾数，
                           并记录小数点移动的次数（左边为正，右边为负）作为阶数，然后把十进制阶数转为移码二进制：具体方法为阶数+127 然后再转成二进制；；需要二进制移码转十进制时，先二进制转十进制，然后减去127
                           注意这里刚好和补码的相反，补码转原码是取反再加1，原码转补码也是取反再加1，但是阶数转换这里转二进制是加，转十进制是减
                  3.一一对应
                           对应符号位，阶数和尾数
         浮点数的特殊表示
                  正负0：阶数全0 尾数全0
                  正负无限：阶数全1 尾数全0
                  NaN: 阶数全1，尾数不全0
                  非规格化数：阶数为0，尾数不全0
                           非规格化数的解读：
                                    非规格化数阶数全0，固定记二进制阶数为2^(-126)[1-127),或者double 2^(-1022)
                                    然后尾数正常解读最高位补0（注意不是1），然后正常解读
                           非规格化数的表示范围：
                                    最大值：阶数全0固定，尾数全1，尾数的真值是0.1111111....,即1-0.000000000...1,即2^(-126) - 2^(-149)
                                    最小值：阶数全0固定，尾数为000....1,真值0.000.....1,即1*2^(-149)
         float浮点数的表示范围：
                  阶数最大表示范围:-126~127(不能全0全1)
                  尾数最大表示范围:(2 - 2^(-23) , 1) （二进制尾数位全0和全1得出）
                  所以结合起来：负数表示范围(不包括0) -(2-2^(-23)) * 2^127 ~ -1 * 2^(-126) ;;; 正数表示范围(不包括0) (1*2^-126) ~ (2-2^(-23)*2^127)
         浮点数溢出
                  上溢
                           当浮点数阶数除了最后一位全为1为11111110，尾数全为1，此时达到正数最大值，负数最小值，此时如果尾数位再加1，就叫上溢出，此时浮点数的值变为正负无限（阶数全1，尾数全0），此时状态寄存器上溢标志位置1
                  下溢
                           当浮点数阶数除了最后一位全为0，尾数全为0，此时达到正数最小值，负数最大值，此时再-1，转为非规格化数（非规格化数再超出表示范围才下溢）
         无效浮点数NaN
                  当除0，根号0，**无穷-无穷**，结果为NaN

计算机数据存储
         单数据数值存储结构
                  大端模式：大位(高位）在低端
                  小端存储：小位在低端  ->适合计算机
         多数据类型结构的拼接
                  计算机支持按字寻址，按半字寻址和字节寻址
                  边界对齐：每个数据数值占用空间为字的整数倍，比如3个char字节存内存，一字4字节，那么最后一个字节填充，满足存储空间为字整数倍，这样计算机不用多次寻址读字，更快但是浪费空间
                  非边界对齐：多数据类型邻接存储，但是比如short2字节，刚好存在字末和下字首，就要两次寻址；；；省空间费时间
         存储系统原理
                  计算机存储系统由寄存器，cache，主存，辅存
                  按类型分类由随机存储器，顺序存储器（sam），直接存储器dam，相联存储器cam（可以按内容取值，如快表），只读存储器，读写存储器，破坏性存储器DRAM，非破坏性sram
                  相关公式
                           容量=字数*字长
                           单位成本 = 总价/总容量
                           数据传输率（带宽）= 存储长度/存储周期（存储时长+恢复时长）
                  ---
                  单块内存芯片的构成：
                           存储矩阵，以半导体管为单位表示1b,一行半导体组成一个存储字，矩阵内有多行多个存储字，mos管引出使能线和数据线，使能线一字共用一条，数据线每个字的相同位共用一条，当一条使能线上电，这个字的所有位被激活，能被数据线读到
                           译码驱动：把地址码转为选择存储矩阵其中一条使能线
                           读写电路：连接存储矩阵数据线和主机数据总线
                           片选线：一个内存条有多块芯片，此线为1说明选中此芯片
                           地址线：选中存储矩阵的第几个字（内存以字为单位读取，所以数据边界对齐会减少内存读写次数）
                           数据线：读或写存储矩阵的某个字
                           读写线：现在是读还是写，可以两条线表示或者一条线表示
                           ---
                           算术：
                                    字地址转为字节地址：字地址左移(单字含多少字节)位，相当于*2^n
                                    存储矩阵容量：看地址线有多少位，就是多少字的容量，*字转字节得到字节容量
                           ---
                           题型：
                                    存储芯片需要多少根引脚：
                                             正负极+地址线(多少位)+片选线+读写线(两条【读，写】或一条【0读1写】)+数据线（字位数b)
                           ---
                           内存特性：
                                    内存是dram（dynamic），采用栅极电容存储数据，【2ms】后电容电量流失数据会丢失，且读操作也会导致数据丢失，所以需要1.重写操作 2.刷新操作
                                    行列地址线：采用行列定位地址线，而不是单行定位地址线，降低了行列地址线的密度
                                             具体来说，对于n位的地址，前n/2位作为行，后n/2位作为列；存储单元（一个字一个单元）按照矩阵排列，就可以同时提供行列就能定位具体字
                                    关键词：存取周期，读写周期，存取时间，恢复时间，
                                    重写操作：
                                             需要另外消耗周期？
                                    刷新操作：
                                             2ms内必须刷新所有存储单元，
                                             刷新操作以行作为单位；；；如果地址线有n位，那么行数为2^(n/2)，在2ms内必须对所有行刷新
                                             假设存取周期（读写周期）为s，存储矩阵为256*256，刷新耗时和存取周期相同
                                                      每次读写后刷新
                                                               存取周期变为2s（读写+刷新），则2ms内能刷新次数为2ms/2s=1/s次
                                                      集中刷新
                                                               要刷新256行，则需要256*s的时间
                                                      平均间隔刷新
                                                               每2ms/256的时间内需要抽一个读写周期出来刷新数据
                           cpu与内存的连接：
                                    数据线，地址线，片选，读写信号，低电平有效，译码器与低电平有效画法
                                    位扩展
                                             数据总线位比单内存芯片的数据位多
                                    字扩展
                                             地址总线位数比单芯片地址多
                  cache构成         
                           cache采用双稳态触发器作为基本存储单位，不会数据消失，且读数据不会毁坏数据（内存会），
                           每个基本单位由一根使能线，两根数据线，数据表示：左数据线低电平为0，右数据线低电平为1
                  ROM分类
                           MROM 不能修改数据
                           PROM 可编程，但只可编程一次
                           EPROM 可多次擦写rom
                           FLASH 可多次擦写rom，因为写之前要擦，所以写比读慢
                           ROM非易失，部分可读写，部分可随机
                  提高主存读写速度
                           多体并行存储器（多内存条一起用）
                                    并行存储器的编址方法
                                             高位多体编址，假设地址有8位，取高2位表示4条内存条，剩下6位表示每条内存条有128个字存储，地址编号递增时是先用完一条内存再用另一条，可以扩展内存，没有并行效果
                                             低位多体编址，假设地址有8位，取低2位表示4条内存，剩下六位表示数据，当地址递增时，连续的地址分布在不同的内存条，这样可以并行，也可以扩容
                                    存储器并行化
                                             假设内存存取周期为T,总线传输周期（读写时间）为r，使用流水线建模，时刻0，调用内存0，时刻r，内存0取完数据，进入恢复时间，此时的空闲时间可以用来调用内存1，时间2r内存1进入恢复态，以此类推，要在内存0完全恢复成可读取状态之前用满所有空闲时间，则需要m=T/r根内存条
                           单体多字读取（一次读取多个字）
                  ---
                  cache原理
                           关键词：命中
                           cache由cache行构成，用于存储经常使用的内存块，每一行由有效位，标记，数据构成；；；数据存储的是内存的一个块（多个字节），数据的大小和内存的一个块大小相同
                           主存的地址可拆分为块号+块内地址
                           ------
                           主存映射
                                    全相联映射，随机映射
                                             cache标志字段存内存块号，数据为存数据，内存地址可拆分为（物理块号，块内偏移，），cache中只记录物理块号，不计片内位移
                                    直接映射
                                             cache位置 = 物理地址 % cache表长度 (标识，cache位置，块内偏移)，cache中只记标识，不记录cache位置位，因为cache地址号可以表示位置，不计片内位移
                                    分组映射
                                             内存在cache的组号 = 内存地址号 / 组数 ；；内存地址可拆分为（标志，组号，块内偏移）；；；只记录标志，比如cache组相联4组，内存有1024字节，4字节一块，有256块，用8位表示，块内4字节用两位，组号两位，标识4位，由4个组，组号占两位
                           替换算法
                                    最近最少使用算法
                                             每个cache行维护一个计数器，用于区分哪个cache行使用最多，然后A.新元素入cache，计数器设0，其他非空闲行计数器+1 B.cache中没有空闲行，寻找计数器最大的行替换，替换的行cache置0，其他加1 C.如果cache行命中，当前行置0，其他计数器比当前行小的行计数器+1;大于等于当前计数器的不用变（同样不丢失行间大小关系，同时更省位数）
                                    随机
                                    先进先出
                           cache写策略
                                    cache在读时未命中，会把数据读入cache
                                    cache的写命中处理策略
                                             1.写回法
                                                      直接写在cache里，替换时再写入内存
                                             2.全写法
                                                      同时写进cahche和内存里
                                    cache写不命中处理策略
                                             写分配法：
                                                      分配到cache，再写
                                             非写分配法
                                                      直接写在内存里，不分配cache上
                                    组合：写分配法一般组合写回法；；；全写法组合非写分配法
                                    多级cache，cache之间一般用全写法+非写分配法；；cache和内存间用写回法+写分配法       
### 指令系统
指令格式：  
         指令由操作码和地址码构成，由定长指令和非定长指令（略）；；；操作码又分为定长操作码和非定长操作码
                  非定长操作码拿地址码的位置当操作码，且短操作码不能是长操作码的前缀
                  假如操作码由前4位构成，则要拓展操作码，至少留最后一个标识数1111作为拓展操作码的标识，然后后面继续4个位表示二级操作码
寻址：
         指令寻址：
                  指令寻址是指寻找下一跳指令的地址
                  指令寻址有三种方法：
                           顺序寻址
                                    PC+1
                           跳跃寻址
                                    JMP  
         数据寻址：
                  是指寻找形式地址对应的有效地址
                  数据寻址方法有多种，通过在地址码之前添加nb的标识符表示：
                           直接寻址-地址码指向实际存储地址；；汇编上通过地址前加#来表示这是个立即数
                           立即寻址-地址码存的是操作数
                           间接寻址（多级）-地址码指向的是指向目标地址的地址指针
                           隐含寻址-有操作数蕴含在相关操作的寄存器上
                           寄存器寻址-地址码指向寄存器位置
                           寄存器间接寻址-寄存器指针
                           相对寻址-相对PC+x
                           基址寻址-操作系统维护一个进程基址寄存器BR,根据BR+x寻址
                           变址寻址-用户可访问IX寄存器，根据IX寻址
                           堆栈寻址-堆栈寄存器SP指向堆栈顶部，
汇编
         汇编常用寄存器：
                  E extend 表示32位
                  EAX(extend A index) 通用寄存器A
                  EBX 通用B
                  ESP 堆栈顶指针寄存器
                  EBP 堆基指针寄存器
                  ESI (extend source index) 变址源寄存器
                  EDI 变址目标寄存器
         汇编常用指令x86（x86汇编所有命令都是先dex 再source）
                  内存位非十六进制数数表示，通常是某些别名
                  mov destination source 注意不是source des 是 des sour
                  x86架构中，PC寄存器又称为IP寄存器
                  #x 立即数
                  dword ptr[] byte ptr[] word ptr[] , 双字，字节，单字指针，获取对应字数的值 
                  mul
                  imul
                  div
                  mdiv
                  shl
                  shr
                  inc
                  dec
                  test
                  jxxx，je,jne,jl,jg,jle,jge 配合cmp使用
                  call 把当前IP值压入程序栈帧内（函数栈帧用于保存函数调用信息和局部变量），然后设置新的ip值调用函数
                  ret  拿回旧的ip值并设置
         汇编指令AT&T
                  指令后是先source 再destination
                  寄存器前加%
                  立即数前加$
                  主存用()括号括起来
                  读写内存不用word ptr表示 用moveb(a1234h),或者movel 或者movew来表示 b-byte l-2word w-word
                  如果主存偏移可表示为基址寄存+变址寄存*比例+偏移 则汇编表示为 offset(%ebx,%ecx,rate)
         汇编实现循环
                  1.条件判断循环
                           设定各个条件下的jmp
                  2.loop 循环
                           loop指令用于返回指定地址
         汇编访问栈帧
                  cpu地址以字节编址，x86系统中，栈帧以4字节为一帧
                  cpu维护ESP,EBP表示栈顶和栈底，然后然后用push,pop或者mov操作
                           push 和 pop call都是对esp进行操作，结果或者源放到目标地址
                  栈帧切换
                           使用call进入函数(IP(PC)压入函数栈，然后PC跳转，然后push ebp，mov ebp esp
                           退出函数使用leave指令，等价于mov esp ebp,pop ebp
                           <img width="1190" height="316" alt="image" src="https://github.com/user-attachments/assets/62038c39-a54a-4af2-84d6-a8ec35dec909" />
                  堆栈内如何传参？
                           调用者把参数放进将要入栈的程序栈帧里的局部变量位
         CISC&RISC
                  <img width="1891" height="969" alt="image" src="https://github.com/user-attachments/assets/e076dd37-7515-4fef-a623-c83bc9428c6e" />
                  乘法指令可以访存一定是CISC

         <img width="1906" height="975" alt="image" src="https://github.com/user-attachments/assets/a9d829c8-f502-4ff0-b938-d438ebf18820" />

### cpu
cpu基本功能是
         1.指令控制
                  取指令 分析指令 执行指令
         2.操作控制
                  产生操作信号操纵各个部件
         3.时间控制
                  控制操作信号的时间和顺序
         4.数据加工
                  算数逻辑运算
         5.中断处理
cpu的基本组成  
         运算器->数据加工
                  基本结构：
                           算数逻辑单元ALU，通用寄存器，暂存寄存器，ACC,PSW构成
                           寄存器统一与数据总线连通，传递信号给ALU的两个输入，其中一个输入有暂存寄存器，ALU输出也有暂存寄存器，总线需要仲裁各个寄存器信号
         控制器->取指 分析 执行 中断处理
                  基本结构
                           程序计数器PC
                           指令寄存器IR(注意和IP区分）
                           指令译码器ID
                           微操作信号发生器（连接PSW)
                           时序系统
                           MAR 存放需要访问的主存地址
                           MDR 存放要写入内存的数据
         寄存器
         中断系统

cpu执行数据流程
         相关概念
                  时钟周期《机器周期《指令周期
                  时钟周期最基础，机器周期由若干时钟周期组成，指令周期包含若干机器周期
                  指令周期可分为四部分：取指周期，间址周期，执行周期，中断周期；；；其中取指和执行是必有的
         执行数据流：
                  取值周期，PC地址放MAR，控制器控制访问主存取指，指令发给MDR，MDR转给IR
                  间址周期：IR中存拿地址码给MAR,控制器给主存，然后返回到MDR
                  执行周期：
                  中断周期：保存SP-1,PC到内存，生成中断程序向量给PC执行
                  cpu中数据通路可以采用总线方式或者专用数据通路的方式
         控制器原理
                  硬布线控制器（用于RISC）
                           控制器根据状态触发器(FE,IND,EX,INT)取指，间址，执行，中断等信息来执行对其他部件的微操作，
                  微程序控制器（用于CISC）：
                           指令》微指令》微命令-》微操作
                           微指令格式：操作码+下一条微指令地址
                           控制器维护一个微指令ROM存储器CM
                           由寄存器CMAR给出要读取的微指令地址
                           CMDR存储微指令
                           控制器依次执行直到状态后发送到总线
                           <img width="618" height="486" alt="image" src="https://github.com/user-attachments/assets/f6c9faf2-f9d3-49b5-bcb3-d3a1d667c325" />
         指令流水线
                  指标：
                           吞吐率
                           加速比
                           效率

# 计组错题
完整的计算机系统包括硬件设备和软件配备，不是主机和外设
汇编语言改成机器语言的过程叫汇编，不是编译，高级语言转机器语言才是编译
机器字长 运算器的字长 指令字长 运算单元的字长 存储字长 存储器的位数 指令字长 可以是半字 单字 双字
磁盘是DAM存储 直接存储器 不是顺序存储器 磁盘既有顺序存储器的特点 也有随机存储器的特点

<img width="522" height="58" alt="image" src="https://github.com/user-attachments/assets/0328a414-9499-4ba7-8fd4-8b9af6845150" />

ROM也有可擦写的，不能由可擦鞋来判断不是ROM；；；U盘是EEPROM

<img width="857" height="323" alt="image" src="https://github.com/user-attachments/assets/8c9f72b2-adcd-43e9-8575-6d5e44b244ce" />

 即使在虚拟存储系统中，cache存的也是物理地址而不是虚拟地址，所以在访问cache前，要先访问快表获取物理地址，快表没有再访问页表
